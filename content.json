{"meta":{"title":"饭窝","subtitle":"活捉一只 Android 狗","description":"描述","author":"Loshine","url":"https://loshine.me"},"pages":[{"title":"","date":"2016-11-16T17:09:19.000Z","updated":"2016-11-16T17:09:19.000Z","comments":false,"path":"about/index.html","permalink":"https://loshine.me/about/index.html","excerpt":"","text":"关于我就是个 Android 从业者，喜欢研究新技术，喜欢一些好玩儿的东西 联系方式 @loshine loshine1992@gmail.com"},{"title":"","date":"2016-11-16T17:09:19.000Z","updated":"2016-11-16T17:09:19.000Z","comments":false,"path":"tags/index.html","permalink":"https://loshine.me/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Yarn 下一代 Node 包管理器","slug":"yarn-next-generation-node-package-manager","date":"2016-10-21T17:22:47.000Z","updated":"2016-11-16T17:09:19.000Z","comments":true,"path":"2016/10/22/yarn-next-generation-node-package-manager/","link":"","permalink":"https://loshine.me/2016/10/22/yarn-next-generation-node-package-manager/","excerpt":"最近前端圈子里最热的话题应该就是 Facebook 新出的包管理器—— Yarn 了，它解决了前端工程师构建项目中许多痛点，类比到 Java 圈子大概就是从 Maven 切换到 Gradle 的爽快吧。","text":"最近前端圈子里最热的话题应该就是 Facebook 新出的包管理器—— Yarn 了，它解决了前端工程师构建项目中许多痛点，类比到 Java 圈子大概就是从 Maven 切换到 Gradle 的爽快吧。 截止到10月22日，Yarn 发布短短十多天就已经达到了让人惊叹的 star 数量 这成绩简直吓死人了，那么接下来就稍微介绍一下它为什么好，为什么这么多人想要用它替换掉 NPM，以及我们该如何使用它吧。 简介简介还用怎么说呢，你只需要知道它是用来替换 NPM 的就可以了。 特性本地缓存类似 Gradle，Yarn 会把使用过的模块在本地缓存一份，如果下次还要用到相同版本的模块，那么将会直接使用本地的而不是访问网络重新获取一份。 这个特性碾压 NPM 了啊有木有！我之前使用 NPM 的时候一直想吐槽这个来着，如果全局安装项目就会依赖环境，如果不全局安装那么每个项目都要重新下载一次包，浪费时间和资源。 安全性安装之前会验证文件完整性，所以不用担心安装到损坏的文件啦 可靠Facebook 都把它用在生产环境中了，Google 也要参与维护了，Github 上那么多的 star，绝壁可靠了吧 更优雅的命令命令相比起 NPM 更容易理解，默认的设置足够贴心，感觉要起飞了 使用说了这么多也心动了，那么我们就开始安装 Yarn 吧。 安装 笔者使用的是 Mac，所以只会介绍 Mac 的安装方法，其它方式请参照 Installation Guide Mac 上有三种安装方式，推荐使用 Homebrew 安装。 Homebrew安装输入以下命令即可 12brew updatebrew install yarn 如果使用 NVM 的话，可以删除依赖中的 node： 1brew uninstall node 安装脚本下载官网提供的安装脚本来安装 1curl -o- -L https://yarnpkg.com/install.sh | bash npm 安装这是最不推荐的一个方式 1npm install --global yarn 验证安装成功选择以上三个方法之中的任意一种安装成功之后，运行如下命令检测是否安装成功 1yarn --version 如果提示没有命令，去修改.zshrc（或.profile, .bashrc）添加如下语句 1export PATH=\"$PATH:$HOME/.yarn/bin\" 常用命令安装完毕了，那么就要使用它了，下面是一些常用命令和 NPM 对应命令的对照表 作用 NPM 命令 Yarn 命令 安装 npm install yarn 安装某个包 npm install xxx —save yarn add xxx 删除某个包 npm uninstall xxx —save yarn remove xxx 开发模式下安装某个包 npm install xxx —save-dev yarn add xxx —dev 更新 npm update —save yarn upgrade 全局安装 npm install xxx –global yarn global add xxx 还有一些包发布者才会用到的命令就不作详细讲解了 总结yarn 目前来说已经可以做到替换 npm 了，赶紧使用它换取更高的工作效率吧，Enjoy it~","categories":[{"name":"技术","slug":"技术","permalink":"https://loshine.me/categories/技术/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://loshine.me/tags/Node/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://loshine.me/categories/技术/"}]},{"title":"集成友盟分析和推送的一些坑","slug":"umeng-analitics-and-push-service","date":"2016-10-10T17:22:47.000Z","updated":"2016-11-16T17:09:19.000Z","comments":true,"path":"2016/10/11/umeng-analitics-and-push-service/","link":"","permalink":"https://loshine.me/2016/10/11/umeng-analitics-and-push-service/","excerpt":"最近公司的项目用到了友盟的统计和推送，在集成的过程中遇到了一点小坑，这里记录一下方便以后查阅。","text":"最近公司的项目用到了友盟的统计和推送，在集成的过程中遇到了一点小坑，这里记录一下方便以后查阅。 集成统计获得 Appkey在集成友盟的统计 SDK 之前肯定要先注册帐号，添加新应用并获取 Appkey。 导入 SDK官网提供了两种导入方式： 下载集成 使用 Gradle 集成 在这里建议使用 Android Studio 并且使用 Gradle 集成，非常简单方便，只需要添加如下依赖即可： 123dependencies &#123; compile 'com.umeng.analytics:analytics:latest.integration'&#125; latest.integration代表友盟统计的最新版本，笔者使用时最新版本为6.0.0 配置项目接下来修改AndroidManifest.xml文件添加权限，填写 Appkey 以及填写渠道 id ： 123456789101112&lt;manifest……&gt; &lt;uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\"/&gt; &lt;uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\"/&gt; &lt;uses-permission android:name=\"android.permission.INTERNET\"/&gt; &lt;uses-permission android:name=\"android.permission.READ_PHONE_STATE\"/&gt; &lt;application ……&gt; …… &lt;activity ……/&gt; &lt;meta-data android:value=\"YOUR_APP_KEY\" android:name=\"UMENG_APPKEY\"/&gt; &lt;meta-data android:value=\"Channel ID\" android:name=\"UMENG_CHANNEL\"/&gt; &lt;/application&gt; &lt;/manifest&gt; 以上需要把UMENG_APPKEY替换成自己的应用的 Appkey，UMENG_CHANNEL替换成对应渠道的渠道号。多渠道打包可以参考美团的多渠道打包方案。 统计页面访问我司的应用界面全部由 Fragment 呈现，Activity 只用作管理 Fragment。 按照文档首先在 Application 类中调用MobclickAgent.openActivityDurationTrack(false) 禁止默认的页面统计方式，这样将不会再自动统计Activity。 然后封装一下 BaseActivity 以统计时长： 12345678910class BaseActivity extends AppCompatActivity &#123; public void onResume() &#123; super.onResume(); MobclickAgent.onResume(this); //统计时长 &#125; public void onPause() &#123; super.onPause(); MobclickAgent.onPause(this); &#125;&#125; 封装 BaseFragment 以统计具体页面： 1234567891011121314151617181920class BaseFragment extends Fragment &#123; public void onResume() &#123; super.onResume(); // 统计页面 MobclickAgent.onPageStart(getPageName()); &#125; public void onPause() &#123; super.onPause(); MobclickAgent.onPageEnd(getPageName()); &#125; /** * 默认页面名是类名，可以给子类重写 */ public String getPageName() &#123; return this.getClass().getName(); &#125; &#125; 帐号统计暂时还未使用，之后补充。 混淆配置按官方文档配置混淆，以免混淆之后的错误 123456789101112-keepclassmembers class * &#123; public &lt;init&gt; (org.json.JSONObject);&#125;-keep public class [您的应用包名].R$*&#123; public static final int *;&#125;-keepclassmembers enum * &#123; public static **[] values(); public static ** valueOf(java.lang.String);&#125; 使用集成测试首先在 Application 中打开测试模式： 1MobclickAgent.setDebugMode(BuildConfig.DEBUG); 然后添加测试设备 这样所有测试数据不会进入应用正式的统计后台，只能在 管理–集成测试–实时日志 里查看，测试数据的数据就不会污染生产环境数据了。 推送服务创建应用首先需要创建应用 )，获取应用对应的 AppKey 和 Umeng Message Secret。 因为之前使用了友盟统计，我们需要从已有应用中添加以保证 AppKey 的唯一。 导入 PushSDK 把下载的 zip 文件解压缩（解压后的文件路径不能有中文） 把解压缩后得到的目录下的 PushSDK 当做 Module 导入到自己的工程 在之前的AndroidManifest.xml的基础上添加 123&lt;meta-data android:name=\"UMENG_MESSAGE_SECRET\" android:value=\"xxxxxxxxxxxxxxxxxxxxxxxxxxxx\"/&gt; 编辑build.gradle添加模块 1234dependencies &#123; // ... compile project(':PushSDK')&#125; 权限配置若主工程的targetSdkVersion为 23 及以上，需要运行时申请存储权限（WRITE_EXTERNAL_STORAGE），否则在 Android 6.0 及以上机型可能出现无法选举宿主的情况。 注册服务在工程的 Application 类的onCreate() 方法中注册推送服务，无论推送是否开启都需要调用此方法： 1234567891011121314PushAgent mPushAgent = PushAgent.getInstance(this);// 注册推送服务，每次调用 register 方法都会回调该接口mPushAgent.register(new IUmengRegisterCallback() &#123; @Override public void onSuccess(String deviceToken) &#123; // 注册成功会返回 device token &#125; @Override public void onFailure(String s, String s1) &#123; &#125;&#125;); 在 BaseActivity 的onCreate方法中添加如下代码启动推送统计： 1PushAgent.getInstance(context).onAppStart(); 混淆配置按照文档配置混淆 123456789101112131415161718192021-dontwarn com.taobao.**-dontwarn anet.channel.**-dontwarn anetwork.channel.**-dontwarn org.android.**-dontwarn org.apache.thrift.**-dontwarn com.xiaomi.**-dontwarn com.huawei.**-keepattributes *Annotation*-keep class com.taobao.** &#123;*;&#125;-keep class org.android.** &#123;*;&#125;-keep class anet.channel.** &#123;*;&#125;-keep class com.umeng.** &#123;*;&#125;-keep class com.xiaomi.** &#123;*;&#125;-keep class com.huawei.** &#123;*;&#125;-keep class org.apache.thrift.** &#123;*;&#125;-keep public class **.R$*&#123; public static final int *;&#125; 集成推送中的一些坑UnsatisfiedLinkError按照如上设置之后运行项目发现会如下报错 1java.lang.UnsatisfiedLinkError: dlopen failed: &quot;/data/data/应用包名/files/libtnet-3.1.7bk1.so&quot; is 32-bit instead of 64-bit 需要在项目根目录的build.gradle中如下设置解决： 123456defaultConfig &#123; // ... ndk &#123; abiFilters \"armeabi\", \"x86\" &#125;&#125; 使用 BuildTypes 修改包名的错误因为友盟使用 ApplicationId 作为包名利用反射获取资源文件，而当 BuildTypes 中的 ApplicationId 改变了导致应用包名和 Java 包名不一致的时候就会导致错误。此时需要在注册推送服务之前重新设置包名： 12345678910111213141516PushAgent mPushAgent = PushAgent.getInstance(this);// 首先重新设置包名mPushAgent.setResourcePackageName(R.class.getPackage().getName());// 注册推送服务，每次调用 register 方法都会回调该接口mPushAgent.register(new IUmengRegisterCallback() &#123; @Override public void onSuccess(String deviceToken) &#123; // 注册成功会返回 device token &#125; @Override public void onFailure(String s, String s1) &#123; &#125;&#125;); 总结以上就是实际项目中集成友盟统计和推送的方法了，查阅资料解决了一些官方文档没有提及的东西，希望可以给后来者一个参考。","categories":[{"name":"技术","slug":"技术","permalink":"https://loshine.me/categories/技术/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://loshine.me/tags/Android/"},{"name":"友盟","slug":"友盟","permalink":"https://loshine.me/tags/友盟/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://loshine.me/categories/技术/"}]},{"title":"Android开发最佳实践——2.使用Kotlin开发Android","slug":"android-best-practice-p2-language","date":"2016-09-05T16:30:21.000Z","updated":"2016-11-16T17:09:19.000Z","comments":true,"path":"2016/09/06/android-best-practice-p2-language/","link":"","permalink":"https://loshine.me/2016/09/06/android-best-practice-p2-language/","excerpt":"","text":"引Android 的官方开发语言是 Java，那为什么我们不继续使用 Java 开发 Android 呢？可能有人会说出很多理由，如： 没有函数式的支持 Android 上只能用到 Java 6 令人烦躁的 NullPointException …… 但实际上我觉得让我们选择 Kotlin 而不是 Java 的原因只有一个：Kotlin 拥有更高的生产力。 下面我就介绍一下 Kotlin 这个语言和它的好处，以及如何使用它编写 Android 程序。 WhatKotlin 是公司 JetBrains 研发的语言（他们家代表产品有 IntellJ Idea、Android Studio 等）。他们的网站上，他们是这样描述 Kotlin 的： 为 JVM、Android 和浏览器而生的静态编程语言。 相比起其它 JVM 上的语言，它拥有无数的优点： 为 Java 作扩展而不是重写 Java，所以它的方法数相比 Groovy 和 Scala 少了很多 和 Java 可以无缝调用，完美利用 JVM 生态 面向对象和函数式的结合，支持多种范式 现代化的语法，解决了 Java 无数痛点（如 NullPointException） …… Kotlin 习语下面简单介绍一些 Kotlin 的习语，看看 Kotlin 是如何简化我们的编码的。 数据类Kotlin 中创建数据类非常简单，我们只需要如下编写代码即可： 1data class Customer(val name: String, val email: String) 使用了data class关键词之后，Kotlin 会自动帮我们生成getter(如果属性是使用var声明的则还会生成setter)、equals()、hashCode()、toString()、copy()等常用方法。 而在 Java 中写一个 JavaBean，我们需要一个个声明属性并写出它们对应的getter、setter以及其它代码，相比之下 Kotlin 的代码量小了一大半。 Lambda因为历史原因我们还在使用 Java6 编写 Android 代码，无法使用到 Java8 的新特性之 Lambda 表达式。而使用 Kotlin 的话是天生支持 Lambda 的，可以大大减少代码量。 Java ver: 123456mTextView.setOnClickListener(new View.OnClickListener()&#123; @Override public void onClick(View view) &#123; // todo ... &#125;&#125;); Kotlin ver: 1mTextView.setOnClickListener &#123; v -&gt; // todo...&#125; 默认非空Kotlin 里声明的类型都是默认非空的，可空的类型必须要在声明类型的时候在类型后面加一个?，而 Kotlin 也提供了语法糖来搞定null判断 123Student aStudentprintln(aStudent.name) 该aStudent永远不会为空 而如果是一个可空的 Student 123Student? bStudentprintln(bStudent?.name) 因为声明类型的时候添加了一个?表示可空，所以bStudent是可能为null的。但 Kotlin 提供的语法糖在使用的时候bStudent?.name不会产生 NullPointException。 字符串插值Java 中格式化字符串是这样的: 1String.format(Locale.getDefault(), \"Name: %s\", student.getName()); Kotlin 中我们可以这样: 1\"Name: $&#123;student.name&#125;\" when 表达式Kotlin 里的 when 表达式非常强大，可以替换掉if-elseif-else 12345when (x) &#123; is Foo -&gt; ... is Bar -&gt; ... else -&gt; ...&#125; 总结上面讲了一些常用的 Kotlin 特性，还有更多没有写出的如：不可变集合,扩展函数,参数默认值等。 我个人的体验是使用 Kotlin 可以大大减少模版代码，让 Coding 更加愉悦。推荐在没有历史包袱的项目中使用。 但如果是有历史包袱的项目或者项目组成员不愿意去另外学习一门语言的话，那可能就无法享受到 Kotlin 的好处了，大家酌情选择即可。","categories":[{"name":"技术","slug":"技术","permalink":"https://loshine.me/categories/技术/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://loshine.me/tags/Android/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://loshine.me/categories/技术/"}]},{"title":"Android开发最佳实践——1.接口设计","slug":"android-best-practice-p1-interface-design","date":"2016-09-01T01:51:21.000Z","updated":"2016-11-16T17:09:19.000Z","comments":true,"path":"2016/09/01/android-best-practice-p1-interface-design/","link":"","permalink":"https://loshine.me/2016/09/01/android-best-practice-p1-interface-design/","excerpt":"","text":"一个项目刚开始的时候，最需要确认的就是接口设计了：数据如何传递，使用什么格式什么协议乃至如何保证安全性。如果一个项目的接口设计不合理——比如没有考虑到安全性，后期为了增加安全验证又要对部分 API 推倒重做，那么前端（泛指 Android、iOS 以及 Web）就必须对整个项目进行改动，甚至可能导致之前发布的版本无法使用的囧事。 那么本文就谈谈我认为的一个好的接口应该是如何设计的。 设计使用 RESTful 风格的 API 设计。 协议使用 HTTPS 协议，保证 HTTP 的方便的同时保证一定的安全性。 域名尽量部署在专属域名下，如 github： 1https://api.github.com/ 版本应该把版本号放到 URL 中，如 API 有改版的时候，应保证老版的 API 持续提供服务一段时间。 1https://api.example.com/v1/ 路径和资源在 Restful 风格的 API 中，每个路径都代表着互联网中的一个资源。所以 URL 地址中应该使用名词，并且因为大多是资源集合，所以应该使用复数形式。如果是有从属关系的资源，应该服从从属关系，下面给出几个例子：` https://api.example.com/v1/posts https://api.example.com/v1/posts/{postId} https://api.example.com/v1/posts/{postId}/comments HTTP 动词HTTP 动词可以完美对应数据库的增删查改操作，于是我们就把 HTTP 动词和我们的增删查改操作对应起来： GET：查询数据 POST：增加数据 PUT：更新数据(客户端提供改变后的完整资源) PATCH：更新数据(客户端更新某几条属性) DELETE：删除数据 示例下面是结合 HTTP 动词和路径提供一些示例： GET /posts ：获取所有文章 POST /posts ：创建一篇文章 GET /posts/{postId} ：获取指定 Id 的文章信息 PUT /posts/{postId} ：修改指定 Id 的文章信息(客户端需要提供全部属性) PATCH /post/{postId} ：修改指定 Id 的文章信息(客户端提供需要修改的部分属性) DELETE /post/{postId} ：删除指定 Id 的文章 GET /posts/{postId}/comments ：获取指定 Id 文章的所有评论 POST /posts/{postId}/comments ：在指定 Id 文章下创建一条评论 Query 查询在 GET 查询的时候我们不可能一次性获取所有资源，那么我们需要提供一些查询条件。 下面是一些常用的查询： ?index=2&amp;size=20 ：第二页每页20条 ?sortby=name&amp;order=asc ：按指定规则与顺序排序 …… 全局信息全局通用信息应该放在请求头里，避免使用 Query 拼接，如： APPID（Android/iOS/H5） APPVER（版本号） CHANNEL（渠道号） APP-BUILD-NUM（内部小版本号） TOKEN NETWORK（网络环境） LANGUAGE（语言） 等 传输数据Request使用 json 格式传输数据，如果需要上传文件则使用表单的形式提交。 Response使用 json 格式传输数据，Content-Type一致设定为application/json。 响应格式应该统一，下面给出一个例子： 名字 类型 含义 code int 状态码 message String 状态信息 data List or Object 数据 time long 时间戳 具体的响应如下： 123456&#123; 'code': 0, 'message': '获取成功', 'data': [&#123;&#125;, &#123;&#125;, &#123;&#125;], // 返回一个集合 'time': 1472435695000&#125; 或者返回某一个数据： 123456&#123; 'code': 0, 'message': '获取成功', 'data': &#123;&#125;, // 返回一个对象 'time': 1472435695000&#125; 安全为了保证客户端与服务端通信的安全，我们使用 HTTPS 协议。 在身份认证上使用 Oauth 2.0 协议，用户登录之后在客户端保存一份 token，避免在客户端持久化存储用户名和密码。之后每次访问需要身份认证的 API 时，必须携带 token 访问。 避免空指针API 设计的时候应该合理帮助前端避免空指针异常，在一些字段或者属性为空的时候应该返回默认值：如 String 返回&quot;&quot;, int 返回0, Object 返回 {}, Array or List 返回 []。 参考 从零开始的Android新项目9 - 前端用后台接口设计 RESTful API 设计指南","categories":[{"name":"技术","slug":"技术","permalink":"https://loshine.me/categories/技术/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://loshine.me/tags/Android/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://loshine.me/categories/技术/"}]},{"title":"RecyclerView.Adapter：全能notify解决方案","slug":"a-universal-solution-of-recyclerview-adapter-notify","date":"2016-08-25T01:51:21.000Z","updated":"2016-11-16T17:09:19.000Z","comments":true,"path":"2016/08/25/a-universal-solution-of-recyclerview-adapter-notify/","link":"","permalink":"https://loshine.me/2016/08/25/a-universal-solution-of-recyclerview-adapter-notify/","excerpt":"","text":"在之前我们用 ListView 或者 GridView 的时候，通知适配器刷新是这样的： 1adapter.notifyDataSetChanged(); 但是当我们使用了更强大的 RecyclerView 之后，如果直接这样通知适配器刷新将不会显示动画效果。它会直接将所有的 item 重新绘制。 我们需要使用如下的方法来通知适配器刷新，这样 RecyclerView 才会显示对应的动画效果： 1234567adapter.notifyItemInserted();adapter.notifyItemChanged();adapter.notifyItemMoved();adapter.notifyItemRemoved();adapter.notifyItemRangeChanged();adapter.notifyItemRangeInserted();adapter.notifyItemRangeRemoved(); 在这次更新的 Support Library 24.2.0 中添加了一个新的工具类，可以用来方便快捷的处理 RecyclerView.Adapter 的通知刷新。 DiffUtilDifUtil 就是这次引入的工具类，它会找出 Adapter 中每一个 Item 对应发生的变化，然后对每一个变化给予对应的刷新。 最重要的就是如下的两个重载方法 12DifUtil.calculateDiff(Callback cb, boolean detectMoves);DifUtil.calculateDiff(Callback cb); 其中DifUtil.calculateDiff(Callback cb);实际上就是DifUtil.calculateDiff(callback, true);所以我们着重研究第一个方法即可。 该方法会接收两个参数，其中第二个参数是一个 boolean 值，查看源码注释我们知道这个参数有如下作用： True if DiffUtil should try to detect moved items, false otherwise. 如果 DiffUtil 尝试检测移动的项目就设为 true，否则设为 false。 这个参数实际上是指定是否需要项目移动的检测，如果设为 false ，那么一个项目移动了会先判定为 remove，再判定为 insert。 而Callback是一个抽象类，它有四个方法需要实现： 123456789101112131415161718192021public abstract static class Callback &#123; /** * 旧的数据源的大小 */ public abstract int getOldListSize(); /** * 新的数据源的大小 */ public abstract int getNewListSize(); /** * 该方法用于判断两个 Object 是否是相同的 Item，比如有唯一标识的时候应该比较唯一标识是否相等 */ public abstract boolean areItemsTheSame(int oldItemPosition, int newItemPosition); /** * 当 areItemsTheSame 返回 true 时调用该方法，返回显示的 Item 的内容是否一致 */ public abstract boolean areContentsTheSame(int oldItemPosition, int newItemPosition);&#125; 如上所述，我们四个需要实现的方法的作用都在注释中写出了。前两个方法都很好理解，需要重点说明的是后两个 areItemsTheSame：这个方法用来判断两个 Object 是否是相同的 Item，此处最好不要简单的用equals方法判断，我们可以根据 Object 的唯一标识或者自己指定一个规则来判断两个 Object 是否是展示的相同的 Item。 areContentsTheSame：该方法只有在areItemsTheSame返回true之后才会被调用，我们在重写该方法的时候，只需要判断两个 Object 显示的元素是否一致即可。如我们有两个 Object，它们可能拥有很多属性，但是其中只有两个属性需要被显示出来，那只要这两个属性一致我们这个方法就要返回true。 使用 DiffUtils 通知刷新下面我们写一个简单的例子来学习使用 DiffUtil 首先我们来一个 Item 对应的数据类： 123456789public class Student &#123; public String id; // 学号是唯一的 public String name; // 名字可能重复 public Student(String id, String name) &#123; this.id = id; this.name = name; &#125;&#125; 然后写一个 Adapter： 12345678910111213141516171819202122232425262728293031323334353637class MyAdapter extends RecyclerView.Adapter&lt;MyAdapter.ViewHolder&gt; &#123; private final List&lt;Student&gt; datas; public MyAdapter(List&lt;Student&gt; datas) &#123; this.datas = datas; &#125; @Override public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view = LayoutInflater.from(parent.getContext()) .inflate(R.layout.item_recycler, parent, false); return new ViewHolder(view); &#125; @Override public void onBindViewHolder(ViewHolder holder, int position) &#123; holder.setData(datas.get(position)); &#125; @Override public int getItemCount() &#123; return datas.size(); &#125; class ViewHolder extends RecyclerView.ViewHolder &#123; public ViewHolder(View itemView) &#123; super(itemView); &#125; public void setData(Student student) &#123; TextView textView = (TextView) this.itemView.findViewById(R.id.text); textView.setText(student.name); &#125; &#125;&#125; 其对应的布局文件就是一个简单的 TextView： 12345678910&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;TextView xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/text\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:gravity=\"center\" android:orientation=\"vertical\" android:padding=\"10dp\" tools:text=\"content\"/&gt; 然后我们在 Activity 里使用它们并显示出来： 123456789101112131415161718class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; // ... mRandom = new Random(); datas = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; datas.add(new Student(mRandom.nextInt(3000) + \"\", \"Students: \" + i)); &#125; mRecyclerView = (RecyclerView) findViewById(R.id.recycler_view); mRecyclerView.setLayoutManager(new LinearLayoutManager(this)); mAdapter = new MyAdapter(datas); mRecyclerView.setAdapter(mAdapter); // ... &#125;&#125; 这样我们就获得了一个简单的展示学生数据的 RecyclerView 了。 然后我们对 Adapter 的数据源进行更改，并通知刷新： 1234567891011121314151617181920212223242526272829303132333435363738mFab.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; // 创建一个原来的 List 的副本 final ArrayList&lt;Student&gt; oldTemp = new ArrayList&lt;&gt;(datas); // 更改原数据源 datas.remove(mRandom.nextInt(mAdapter.getItemCount())); for (int i = 0; i &lt; mRandom.nextInt(3); i++) &#123; datas.add(mRandom.nextInt(mAdapter.getItemCount() - 1), new Student(mRandom.nextInt(3000) + \"\", \"Students: \" + mRandom.nextDouble())); &#125; // 实现 Callback DiffUtil.Callback callback = new DiffUtil.Callback() &#123; @Override public int getOldListSize() &#123; return oldTemp.size(); &#125; @Override public int getNewListSize() &#123; return datas.size(); &#125; @Override public boolean areItemsTheSame(int oldItemPosition, int newItemPosition) &#123; return oldTemp.get(oldItemPosition).id.equals(datas.get(newItemPosition).id); &#125; @Override public boolean areContentsTheSame(int oldItemPosition, int newItemPosition) &#123; return oldTemp.get(oldItemPosition).name.equals(datas.get(newItemPosition).name); &#125; &#125;; DiffUtil.DiffResult diffResult = DiffUtil.calculateDiff(callback); // 把结果应用到 adapter diffResult.dispatchUpdatesTo(mAdapter); &#125; &#125;); 效果如下： DiffUtil 的使用就是这样，根据 DiffUtil.Callback 计算出 Result，然后应用更新到 Adapter。 封装有的人可能说了，这样其实并不好用啊，我们原来数据的改变就直接使用对应的方法就可以了，你这里每次还要写得这么麻烦。那么我们就使用 DiffUtil 和 Adapter 结合再进行一次封装吧。 我们抽取一个 BaseAdapter 出来： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public abstract class BaseAdapter&lt;T, V extends RecyclerView.ViewHolder&gt; extends RecyclerView.Adapter&lt;V&gt;&#123; protected final List&lt;T&gt; temp; // 用于保存修改之前的数据源的副本 protected final List&lt;T&gt; datas; // 数据源 public BaseAdapter(List&lt;T&gt; datas) &#123; this.datas = datas; temp = new ArrayList&lt;&gt;(datas); &#125; protected abstract boolean areItemsTheSame(T oldItem, T newItem); protected abstract boolean areContentsTheSame(T oldItem, T newItem); @Override public int getItemCount() &#123; return datas.size(); &#125; public void notifyDiff() &#123; DiffUtil.DiffResult diffResult = DiffUtil.calculateDiff(new DiffUtil.Callback() &#123; @Override public int getOldListSize() &#123; return temp.size(); &#125; @Override public int getNewListSize() &#123; return datas.size(); &#125; // 判断是否是同一个 item @Override public boolean areItemsTheSame(int oldItemPosition, int newItemPosition) &#123; return BaseAdapter.this.areItemsTheSame(temp.get(oldItemPosition), datas.get(newItemPosition)); &#125; // 如果是同一个 item 判断内容是否相同 @Override public boolean areContentsTheSame(int oldItemPosition, int newItemPosition) &#123; return BaseAdapter.this.areContentsTheSame(temp.get(oldItemPosition), datas.get(newItemPosition)); &#125; &#125;); diffResult.dispatchUpdatesTo(this); // 通知刷新了之后，要更新副本数据到最新 temp.clear(); temp.addAll(datas); &#125;&#125; 然后我们只需要令 Adapter 实现 BaseAdapter即可： 12345678910111213141516171819202122232425262728293031323334353637383940class MyAdapter extends BaseAdapter&lt;Student, MyAdapter.ViewHolder&gt; &#123; public MyAdapter(List&lt;Student&gt; datas) &#123; super(datas); &#125; @Override public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view = LayoutInflater.from(parent.getContext()) .inflate(R.layout.item_recycler, parent, false); return new ViewHolder(view); &#125; @Override public void onBindViewHolder(ViewHolder holder, int position) &#123; holder.setData(datas.get(position)); &#125; @Override public boolean areItemsTheSame(Student oldItem, Student newItem) &#123; return oldItem.id.equals(newItem.id); &#125; @Override public boolean areContentsTheSame(Student oldItem, Student newItem) &#123; return oldItem.name.equals(newItem.name); &#125; class ViewHolder extends RecyclerView.ViewHolder &#123; public ViewHolder(View itemView) &#123; super(itemView); &#125; public void setData(Student student) &#123; TextView textView = (TextView) this.itemView.findViewById(R.id.text); textView.setText(student.name); &#125; &#125;&#125; 之后我们如果数据源 List 中的数据有任何改动，我们只需要调用notifyDiff()就可以了： 1234567891011mFab.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; datas.remove(mRandom.nextInt(mAdapter.getItemCount())); for (int i = 0; i &lt; mRandom.nextInt(3); i++) &#123; datas.add(mRandom.nextInt(mAdapter.getItemCount() - 1), new Student(mRandom.nextInt(3000) + \"\", \"Students: \" + mRandom.nextDouble())); &#125; mAdapter.notifyDiff(); &#125; &#125;); 总结最新 Support 包中的 DiffUtil 类给我们带来了一个对 RecyclerView 的不同数据变化的统一处理方案，可以对所有数据变化之后的通知刷新简化，非常好用，强烈推荐使用。 参考Android开发学习之路-DiffUtil使用教程","categories":[{"name":"技术","slug":"技术","permalink":"https://loshine.me/categories/技术/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://loshine.me/tags/Android/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://loshine.me/categories/技术/"}]},{"title":"自定义View之自定义属性","slug":"custom-view-attrs","date":"2016-08-13T14:32:31.000Z","updated":"2016-11-16T17:09:19.000Z","comments":true,"path":"2016/08/13/custom-view-attrs/","link":"","permalink":"https://loshine.me/2016/08/13/custom-view-attrs/","excerpt":"定义一个控件我们先画一个简单的圆形 View，在onDraw中绘制。","text":"定义一个控件我们先画一个简单的圆形 View，在onDraw中绘制。 1234567891011121314151617181920212223242526272829303132333435public class CircleView extends View &#123; private Paint mPaint; public CircleView(Context context) &#123; super(context); init(); &#125; public CircleView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public CircleView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(); &#125; @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP) public CircleView(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) &#123; super(context, attrs, defStyleAttr, defStyleRes); init(); &#125; private void init() &#123; mPaint = new Paint(); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawCircle(100, 100, 100, mPaint); &#125;&#125; 然后在布局文件中使用： 123&lt;io.github.loshine.customview.view.CircleView android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /&gt; 然后我们就可以在 preview 窗口中看到效果了 一个很简单的黑色的圆形 定义需要的属性现在我觉得黑色不好看了，我想给它换个颜色，那么一般来说可以用Paint.setColor(int color)来修改为其它的颜色。但这会让所有的 CircleView 都变成另一个颜色。 但我可能希望在一个 Activity 里的 CircleView 是红色，但在另一个中的是蓝色。 此时我们就需要给该 View 自定义属性了。 自定义属性就类似 TextView 的android:text=&quot;xxx&quot;，ImageView 的android:src=&quot;@drawable/xxx&quot;，可以给相同类型的 View 设置不同的属性展示不同的效果。 这里我们定义一个 color 属性。 声明属性名称在res/values文件夹下新建一个资源文件，叫 attrs.xml 123456&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources&gt; &lt;declare-styleable name=\"CircleView\"&gt; &lt;attr name=\"circle_color\" format=\"color\" /&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 这样就完成了属性名称的声明。 declare-styleable的 name 可以任意命名，只要不重复即可，但一般我们会使用自定义控件的类名方便管理。attr标签中定义的就是需要自定义的属性名称和类型。 我们有这几种类型： boolean color dimension enum flag float fraction integer reference string 声明完成之后就可以在代码中根据对应的方法获取布局中使用的自定义属性了。 获取属性构造方法我们在自定义 View 的时候 IDE 通常会提醒我们需要拥有构造函数，然后我们使用其智能提醒会发现有四个构造函数供我们选择： 1234public View(Context context);public View(Context context, AttributeSet attrs);public View(Context context, AttributeSet attrs, int defStyleAttr);public View(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) 查看源码注释，我们知道这四个方法分别对应不同方式创建 View： View(context)：直接在代码中 new 出来 View(context, attrs)：当 View 是从布局文件 inflate 出来的时候会调用这个构造方法，使用默认的 style 和 theme。 View(context, attrs, defStyleAttr)：该方法不会被系统直接调用，我们需要手动调用。该方法相比第二个方法多了一个默认 style 的参数，它的作用就是为 View 提供一个基本的样式。 View(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes)：将资源文件中定义的某个样式作为默认样式。 我们在实现自定义 View 的时候，通常至少有两个构造方法（至于为什么我们后文再说），分别是View(Context context)以及View(Context context, AttrbuteSet attires)，这样我们才可以在 Java 代码中以及在布局文件中（或使用 Inflater）实例化它们。 obtainStyledAttributes看过了 View 的构造方法，我们现在就要在构造方法里获取 View 的参数了。Context这个类为我们提供了以下几个方法来获取属性： 1234obtainAttributes(AttributeSet set, int[] attrs) // 从 layout 设置的属性集中获取 attrs 中的属性obtainStyledAttributes(int[] attrs) // 从系统主题中获取 attrs 中的属性obtainStyledAttributes(int resId, int[] attrs) // 从资源文件定义的 style 中读取属性obtainStyledAttributes(AttributeSet set, int[] attrs, int defStyleAttr, int defStyleRes) // 后面详细说这个方法 我们了解一下这几个 API 的参数，然后就可以很方便的获取自定义属性了。 参数解析attrs就是我们需要获取属性集中的哪些属性，通常我们会定义一个&lt;styleable&gt;来管理所有的&lt;attr&gt;，然后我们就可以用R.styleable.someAttrs来使用这个参数了。 AttrbuteSet即我们在 xml 中定义的属性的集合，如： 12345&lt;Button android:id=\"@+id/dial_button\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"@string/dial\" /&gt; 这里我们的每一条属性都会放到 AttrbuteSet 中去，当然自定义属性也不例外。需要注意的是，style=&quot;@style/somestyle&quot;这样添加的属性也是会放进去的。 这也是我们必须要实现View(Context context, AttrbuteSet attr)的原因，因为我们需要把布局文件中定义的参数传进来处理。 defStyleAttrs这是自定义属性中可以让其在 Theme 中配置的关键，使用它作为参数会从当前 Theme 中去获取参数。 resId/defStyleRes直接从资源文件中定义的某个样式中读取。 Null注意到我们有一个方法只需要attrs作为参数，那它的属性从哪里来呢？其实是我们可以直接在 Theme 中指定属性并且用这个方法获取属性。 四个参数obtainStyledAttributes(AttributeSet set, int[] attrs, int defStyleAttr, int defStyleRes)这个方法有四个参数，我们获取到的属性可能从四个地方来：布局文件(set), defStyleAttr(主题可配置样式), defStyleRes(默认样式), NULL(主题中直接获取) 如果一个属性在多个地方都被定义了，那么它们的优先级如下： set&gt;defStyleAttr&gt;defStyleRes&gt;NULL TypedArray通过obtainStyledAttributes()我们就拿到了 TypedArray，我们需要的属性都存在里面。然后我们可以对应声明的时候的类型，使用对应的getXXX()方法来获取自定义属性，之后我们就可以使用自定义属性来绘图了。 实例我们将上述的圆形控件修改为五种不同颜色的同心圆，然后使用上面的不同定义属性的方式来定义一遍并且使用。 首先我们的圆形 View 改成这样了： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class CircleView extends View &#123; private Paint mPaint; private int mColor1 = Color.BLACK; private int mColor2 = Color.BLACK; private int mColor3 = Color.BLACK; private int mColor4 = Color.BLACK; private int mColor5 = Color.BLACK; public CircleView(Context context) &#123; this(context, null); &#125; public CircleView(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public CircleView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.CircleView, defStyleAttr, R.style.default_style); mColor1 = typedArray.getColor(R.styleable.CircleView_circle_color1, Color.BLACK); mColor2 = typedArray.getColor(R.styleable.CircleView_circle_color2, Color.BLACK); mColor3 = typedArray.getColor(R.styleable.CircleView_circle_color3, Color.BLACK); mColor4 = typedArray.getColor(R.styleable.CircleView_circle_color4, Color.BLACK); mColor5 = typedArray.getColor(R.styleable.CircleView_circle_color5, Color.BLACK); typedArray.recycle(); init(); &#125; private void init() &#123; mPaint = new Paint(); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); mPaint.setColor(mColor1); canvas.drawCircle(100, 100, 100, mPaint); mPaint.setColor(mColor2); canvas.drawCircle(100, 100, 80, mPaint); mPaint.setColor(mColor3); canvas.drawCircle(100, 100, 60, mPaint); mPaint.setColor(mColor4); canvas.drawCircle(100, 100, 40, mPaint); mPaint.setColor(mColor5); canvas.drawCircle(100, 100, 20, mPaint); &#125;&#125; 然后在attrs.xml中如下定义： 12345678910111213&lt;resources&gt; &lt;declare-styleable name=\"CircleView\"&gt; &lt;!-- 对应五个同心圆的颜色 --&gt; &lt;attr name=\"circle_color1\" format=\"color\"/&gt; &lt;attr name=\"circle_color2\" format=\"color\"/&gt; &lt;attr name=\"circle_color3\" format=\"color\"/&gt; &lt;attr name=\"circle_color4\" format=\"color\"/&gt; &lt;attr name=\"circle_color5\" format=\"color\"/&gt; &lt;/declare-styleable&gt; &lt;!-- 定义 theme 可配置 style --&gt; &lt;attr name=\"circle_style\" format=\"reference\"/&gt;&lt;/resources&gt; 然后我们的style.xml中是这样的： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;resources&gt; &lt;!-- Base application theme. --&gt; &lt;style name=\"AppTheme\" parent=\"Theme.AppCompat.Light.DarkActionBar\"&gt; &lt;!-- Customize your theme here. --&gt; &lt;item name=\"colorPrimary\"&gt;@color/colorPrimary&lt;/item&gt; &lt;item name=\"colorPrimaryDark\"&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name=\"colorAccent\"&gt;@color/colorAccent&lt;/item&gt; &lt;!-- 配置style --&gt; &lt;item name=\"circle_style\"&gt;@style/custom_theme&lt;/item&gt; &lt;!-- 直接在主题中指定 --&gt; &lt;item name=\"circle_color1\"&gt;#ffff00ff&lt;/item&gt; &lt;item name=\"circle_color2\"&gt;#ffff00ff&lt;/item&gt; &lt;item name=\"circle_color3\"&gt;#ffff00ff&lt;/item&gt; &lt;item name=\"circle_color4\"&gt;#ffff00ff&lt;/item&gt; &lt;item name=\"circle_color5\"&gt;#ffff00ff&lt;/item&gt; &lt;/style&gt; &lt;!-- 主题中配置的style --&gt; &lt;style name=\"custom_theme\"&gt; &lt;item name=\"circle_color1\"&gt;#ffff0000&lt;/item&gt; &lt;item name=\"circle_color2\"&gt;#ffff0000&lt;/item&gt; &lt;item name=\"circle_color3\"&gt;#ffff0000&lt;/item&gt; &lt;/style&gt; &lt;!-- 直接在layout文件中引用的style，最后会被放到set中 --&gt; &lt;style name=\"myStyle\"&gt; &lt;item name=\"circle_color1\"&gt;#ff00ff00&lt;/item&gt; &lt;item name=\"circle_color2\"&gt;#ff00ff00&lt;/item&gt; &lt;/style&gt; &lt;style name=\"default_style\"&gt; &lt;item name=\"circle_color1\"&gt;#ffffff00&lt;/item&gt; &lt;item name=\"circle_color2\"&gt;#ffffff00&lt;/item&gt; &lt;item name=\"circle_color3\"&gt;#ffffff00&lt;/item&gt; &lt;item name=\"circle_color4\"&gt;#ffffff00&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; 在布局中我们是这样使用的： 12345&lt;io.github.loshine.customview.view.CircleView style=\"@style/myStyle\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" app:circle_color1=\"#ff00ffff\"/&gt; 如上配置，我们效果如图所示： 可以看出我们的 color4 没有起效果，这是因为使用了 defStyle，这个时候默认 Style 就不会起作用了。 参考文章深入理解Android 自定义attr Style styleable以及其应用","categories":[{"name":"技术","slug":"技术","permalink":"https://loshine.me/categories/技术/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://loshine.me/tags/Android/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://loshine.me/categories/技术/"}]},{"title":"夜间模式初探","slug":"night-mode-in-android","date":"2016-06-01T14:19:13.000Z","updated":"2016-11-16T17:09:19.000Z","comments":true,"path":"2016/06/01/night-mode-in-android/","link":"","permalink":"https://loshine.me/2016/06/01/night-mode-in-android/","excerpt":"","text":"Android Support Library 23.2.0 版为我们带来了官方的夜间模式，现在我们可以很容易地为 App 开发夜间模式了。 如何使用使用起来非常简单，我们只需要将主题继承其即可 1234&lt;!-- parent 为 Theme.AppCompat.DayNight --&gt;&lt;style name=\"AppTheme\" parent=\"Theme.AppCompat.DayNight\"&gt; &lt;!-- Blah blah --&gt;&lt;/style&gt; 应用全局主题然后我们在程序中调用方法设置模式即可，推荐在 Application 的onCreate()中进行设置 1AppCompatDelegate.setDefaultNightMode(int mode); 它有四个可选值，分别是： MODE_NIGHT_NO： 使用亮色(light)主题 MODE_NIGHT_YES：使用暗色(dark)主题 MODE_NIGHT_AUTO：根据当前时间自动切换 亮色(light)/暗色(dark)主题 MODE_NIGHT_FOLLOW_SYSTEM(默认选项)：设置为跟随系统，通常为 MODE_NIGHT_NO 组件主题我们也可以为某一个组件设置主题，通过getDelegate().setLocalNightMode(int mode);即可。注意如果改变了 Activity 的主题，我们需要调用recreate()重启来显示改变后的效果。 获取当前主题应用全局主题和设置相对应，非常简单 1AppCompatDelegate.getDefaultNightMode(); 组件主题如果没有为组件单独设置主题，那么将会获取全局主题，否则获取到组件的主题。 12345678910int currentNightMode = getResources().getConfiguration().uiMode &amp; Configuration.UI_MODE_NIGHT_MASK;switch (currentNightMode) &#123; case Configuration.UI_MODE_NIGHT_NO: // Night mode is not active, we're in day time case Configuration.UI_MODE_NIGHT_YES: // Night mode is active, we're at night! case Configuration.UI_MODE_NIGHT_UNDEFINED: // We don't know what mode we're in, assume notnight&#125; 属性和资源对应夜间模式，我们会需要在不同的模式下使用不同的资源文件或不同的属性，此时我们可以新建一个带-night后缀的资源文件夹，然后再创建对应的资源文件即可，比如：drawable-night、values-night等。 此时如果应用切换到了夜间模式，将会自动使用-night后缀中对应的资源。 非夜间模式的后缀是-notnight，但是因为不是夜间模式就不会使用-night里的资源所以一般我们没必要使用这个后缀。 主题适配按照如上设置了之后还可能会出现一些问题如夜间模式下文字颜色还是黑色的所以看不清了（直接给 TextView 设置了textColor=&quot;@color/xxx&quot;，而比较建议的是直接引用主题属性或者给不同模式设置不同的资源。 如字体颜色一般使用?android:attr/textColorPrimary，图标颜色一般使用?attr/colorControlNormal等。 WebView 的主题适配WebView 因为没有特别的处理，所以我们需要通过加载特殊的 css 来完成夜间模式的适配。通过判断现在处于哪种主题然后切换对应的 css 即可。","categories":[{"name":"技术","slug":"技术","permalink":"https://loshine.me/categories/技术/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://loshine.me/tags/Android/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://loshine.me/categories/技术/"}]},{"title":"Anroid中的自定义View测量","slug":"measure-custom-view-in-android","date":"2016-04-21T16:51:22.000Z","updated":"2016-11-16T17:09:19.000Z","comments":true,"path":"2016/04/22/measure-custom-view-in-android/","link":"","permalink":"https://loshine.me/2016/04/22/measure-custom-view-in-android/","excerpt":"","text":"之前已经讲过了 Android 中 View 的绘制流程，上次主要讲的是onDraw方法，这次主要讲的就是在onMeasure方法中对 View 的大小进行测量。 理解 MeasureSpec要了解如何在onMeasure方法中对 View 进行测量，我们首先需要了解的就是onMeasure方法传入的两个 int 值：widthMeasureSpec 和 heightMeasureSpec。 它们都是32位的 int 值，高2位代表 SpecMode(测量模式)，低30位代表 SpecSize(对应模式下的测量大小)。通过以下的代码我们可以了解到 MeasureSpec 的原理： 12345678910111213141516171819202122232425private static final int MODE_SHIFT = 30; // Mode 的移位(高2位也就是左移30位)// 以下四个都是 Mode 常量private static final int MODE_MASK = 0x3 &lt;&lt; MODE_SHIFT;private static final int UNSPECIFIED = 0 &lt;&lt; MODE_SHIFT;private static final int EXACTLY = 1 &lt;&lt; MODE_SHIFT;private static final int AT_MOST = 2 &lt;&lt; MODE_SHIFT;// 该方法用于组装 MeasureSpec，其中 sUseBrokenMakeMeasureSpec 是一个兼容参数，如果为 true 时可能会出错(sdk19之后默认走底下的逻辑)public static int makeMeasureSpec(int size, int mode) &#123; if (sUseBrokenMakeMeasureSpec) &#123; return size + mode; &#125; else &#123; return (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK); &#125;&#125;// 获取 Modepublic static int getMode(int measureSpec) &#123; return (measureSpec &amp; MODE_MASK);&#125;// 获取 Sizepublic static int getSize(int measureSpec) &#123; return (size &amp; ~MODE_MASK);&#125; 因为 Android 中会有大量的 View 存在，所以必然会有很多 MeasureSpec，如果将 MeasureSpec 封装成一个对象必然会造成大量的对象内存分配，这也不难理解为什么要将其包装成一个 int 了。 SpecModeSpecMode 有三类，我们在前面的代码定义中看到了有五个常量，其中两个是作为工具存在的（MODE_SHIFT 和 MODE_MASK），另外三个就是 SpecMode 了。 UNSPECIFIED该模式下父容器不对 View 的大小有任何限制，一般不做处理。 EXACTLY父容器已经检测出 View 所需要的精确大小，此时 View 的最终大小就是 SpecSize 指定的大小。 对应 LayoutParams 中match_parent以及具体数值。 AT_MOST父容器指定了一个 SpecSize，View 不能大于这个值。 它对应于 LayoutParams 中的wrap_content。 与 Layout_Params 的关系在 View 测量的时候，会将 Layout_Params 在父容器的约束下转换成对应的 MeasureSpec，然后根据这个 MeasureSpec 确认 View 测量后的宽高。一旦 MeasureSpec 确认了，在onMesure中就可以确认 View 的测量宽高了。 match_parent: 对应 EXACTLY 精确值: 对应 EXACTLY wrap_content: 对应 AT_MOST measure 过程measure 过程要分为 View 和 ViewGroup，它们的测量是不同的 View由其measure方法完成，该方法是final关键字修饰的，无法重写。但measure会调用onMeasure，所以只需要看onMeasure如何实现即可。 1234567891011121314151617181920212223242526272829protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasureDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), HeightMeasureSpec));&#125;public static int getDefaultSize(int size, int measureSpec) &#123; int result = size; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) &#123; case MeasureSpec.UNSPECIFIED: result = size; break; case MeasureSpec.ATMOST: case MeasureSpec.EXACTLY: result = specSize; break; &#125; return result;&#125;protected int getSuggestedMinimumWidth() &#123; return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());&#125;protected int getSuggestedMinimumHeight() &#123; return (mBackground == null) ? mMinHeight : max(mMinHeight, mBackground.getMinimumHeight());&#125; 其逻辑很简单，getDefaultSize方法中可以看出，View 的宽高由 SpecSize 决定。于是我们知道：直接继承 View 的自定义控件需要重写onMeasure方法并设置wrap_content时的自身大小，否则使用wrap_content属性是无效的(等同于match_parent)。 所以我们可以这样实现来使得wrap_content生效： 12345678910111213protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec); int widthSpecSize = MeasureSpec.getSize(widthMeasureSpec); int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec); int heightSpecSize = MeasureSpec.getSize(heightMeasureSpec); int realWidth = widthSpecMode == MeasureSpec.AT_MOST ? mWidth : widthSpecSize; int realHeight = heightSpecMode == MeasureSpec.AT_MOST ? mHeight : heightSpecSize; setMeasuredDimension(realWidth, realHeight);&#125; 在如上代码中我们只需要指定默认最小时的mWidth,mHeight即可(wrap_content的默认宽高)，其它模式下交给系统测量即可。 需要注意的是onMeasure方法中获取到的测量宽高并不一定就是控件的最终宽高，比如 RelativeLayout 中的控件会有多次测量，LinearLayout 中的子控件如果设置了weight也会有多次测量，那么第一次onMeasure的就不会准了。 ViewGroup其实就是在测量自己的宽高之后还会调用measureChildren来遍历子控件并且测量子控件的大小。 12345678910111213141516171819202122protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) &#123; final int size = mChildrenCount; final View[] children = mChildren; for (int i = 0; i &lt; size; ++i) &#123; final View child = children[i]; if ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123; measureChild(child, widthMeasureSpec, heightMeasureSpec); &#125; &#125;&#125;protected void measureChild(View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec) &#123; final LayoutParams lp = child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec);&#125; ViewGroup 是一个抽象类，其onMeasure方法是没有具体实现的，所以我们继承 ViewGroup 必须重写onMeasure，重写该方法需要进行的步骤如下： 调用super.onMeasure(widthMeasureSpec, heightMeasureSpec)处理非wrap_content的情况 单独处理wrap_content，即 SpecMode 为AT_MOST的情况 遍历子 View，并测量子 View 测量子 View 我们可以使用这几个方法 12345678910// 使用子view自身的测量方法subView.measure(int wSpec, int hSpec);// ViewGroup 的测量子 View 方法// 某一个子view，多宽，多高, 内部加上了 viewGroup 的 padding 值measureChild(subView, int wSpec, int hSpec); // 所有子view 都是 多宽，多高, 内部调用了 measureChild 方法measureChildren(int wSpec, int hSpec);// 某一个子view，多宽，多高, 内部加上了 viewGroup 的 padding 值、margin 值和传入的宽高 wUsed、hUsedmeasureChildWithMargins(subView, intwSpec, int wUsed, int hSpec, int hUsed); 总结View 的测量基本就是如上所述了，自定义 View 需要重写onMeasure方法并对wrap_content进行特殊处理，其实说起来需要做的并不多，但原理还是满复杂的，全部了解了之后还是觉得学到了不少东西。","categories":[{"name":"技术","slug":"技术","permalink":"https://loshine.me/categories/技术/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://loshine.me/tags/Android/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://loshine.me/categories/技术/"}]},{"title":"背景色渐变的引导页","slug":"guide-with-gradual-background","date":"2016-03-31T18:03:33.000Z","updated":"2016-11-16T17:09:19.000Z","comments":true,"path":"2016/04/01/guide-with-gradual-background/","link":"","permalink":"https://loshine.me/2016/04/01/guide-with-gradual-background/","excerpt":"","text":"使用什么实现还用问么，ViewPager 以及 Fragment 呀，非常简单。 关键 API下面的 API 可以根据初始颜色和结束颜色计算中间值。 1Object ArgbEvaluator.evaluate(float fraction, Object startValue, Object endValue); 具体实现布局 activity_main.xml 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\"me.loshine.guidedemo.MainActivity\"&gt; &lt;android.support.v4.view.ViewPager android:id=\"@+id/view_pager\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"/&gt;&lt;/RelativeLayout&gt; 处理滑动背景色 MainActivity.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public class MainActivity extends AppCompatActivity implements ViewPager.OnPageChangeListener &#123; ViewPager mViewPager; private int[] colors; private int state = ViewPager.SCROLL_STATE_IDLE; // 初始位于停止滑动状态 private ArgbEvaluator mArgbEvaluator; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initColors(); initViewPager(); &#125; /** * 初始化 ViewPager */ private void initViewPager() &#123; mViewPager = (ViewPager) findViewById(R.id.view_pager); if (mViewPager != null) &#123; // 初始颜色 mViewPager.setBackgroundColor(colors[0]); mViewPager.setAdapter(new FragmentStatePagerAdapter(getSupportFragmentManager()) &#123; @Override public Fragment getItem(int position) &#123; return GuideBaseFragment.newInstance(position); &#125; @Override public int getCount() &#123; return 4; &#125; &#125;); mViewPager.addOnPageChangeListener(this); &#125; &#125; /** * 初始化颜色 */ private void initColors() &#123; colors = new int[4]; colors[0] = getResources().getColor(R.color.guideBackgroundColor1); colors[1] = getResources().getColor(R.color.guideBackgroundColor2); colors[2] = getResources().getColor(R.color.guideBackgroundColor3); colors[3] = getResources().getColor(R.color.guideBackgroundColor4); mArgbEvaluator = new ArgbEvaluator(); &#125; @Override public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) &#123; // 只要不是滑动停止状态就计算颜色 if (state != ViewPager.SCROLL_STATE_IDLE) &#123; if (positionOffset &gt; 0 &amp;&amp; position &lt; 4) &#123; int evaluatePreColor = (int) mArgbEvaluator .evaluate(positionOffset, colors[position], colors[position + 1]); mViewPager.setBackgroundColor(evaluatePreColor); &#125; else if (positionOffset &lt; 0 &amp;&amp; position &gt; 0) &#123; int evaluateNextColor = (int) mArgbEvaluator .evaluate(-positionOffset, colors[position], colors[position - 1]); mViewPager.setBackgroundColor(evaluateNextColor); &#125; &#125; &#125; @Override public void onPageSelected(int position) &#123; &#125; @Override public void onPageScrollStateChanged(int state) &#123; this.state = state; &#125;&#125; 总结其实实现方式并不复杂，监听 ViewPager 的滚动然后计算中间值即可，重要的是又学习到酷炫的新东西了。","categories":[{"name":"技术","slug":"技术","permalink":"https://loshine.me/categories/技术/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://loshine.me/tags/Java/"},{"name":"Android","slug":"Android","permalink":"https://loshine.me/tags/Android/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://loshine.me/categories/技术/"}]},{"title":"在Android开发中使用Lambda表达式","slug":"use-lambda-in-android","date":"2016-03-30T15:33:11.000Z","updated":"2016-11-16T17:09:19.000Z","comments":true,"path":"2016/03/30/use-lambda-in-android/","link":"","permalink":"https://loshine.me/2016/03/30/use-lambda-in-android/","excerpt":"","text":"由于三体人对我们的科技封锁，我们无法在 Android 开发中启用 Java 1.8 的重要特性——Lambda 表达式。但现在我们可以通过一些工具启用它，然后使用 Lambda 表达式替换没有什么实际意义的单方法匿名内部类。 Lambda表达式可能有些人还不太清楚到底什么是 Lambda 表达式，这里先对 Lambda 表达式进行一个简单的介绍。 Lambda 表达式是函数式编程语言的特性，它简单的说就是一个匿名函数。 我们先看一个 Groovy 的例子： 1[1, 2, 3, 4, 5].asList().forEach &#123; x -&gt; println x &#125; 在这个例子中，我们使用foreach来遍历一个List并打印每一个值。我们传入了一个 Lambda 表达式：{ x -&gt; println x }，这个表达式就是我们对每一个值进行的操作，在本例中就是打印它们。 在这里 Lambda 表达式是一个映射函数，foreach接受了它作为参数，然后对List中的每一个值进行遍历。 在函数式编程语言中，函数是一等公民（first class）。它们也可以作为变量或者参数被传递而且它们也是一个类。 但在 Java 中函数并不是一等公民，如果我们需要传递一个方法，必须要有一个对象包含这个方法，然后把这个对象传递过去。 所以我们经常会见到类似这样的代码： 123456textView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; // do what you want... &#125;&#125;); 但是实际上，我们需要的只是onClick这个方法里面的内容，其它的部分（new OnClickListener）实在是没有什么实际的意义，只是一个必须的语法而已。 所以 Java 1.8 也引入了部分函数式编程的特性——Lambda 表达式。 如果使用 Lambda 表达式，上面那个例子可以被简化为这样 123textView.setOnClickListener(v -&gt; &#123; // do what you want...&#125;); 如果只有一行代码我们还可以省略大括号 1textView.setOnClickListener(v -&gt; doSomething()); 当啷啷~ 是不是省略了很多代码，有没有很爽的感觉。 有了 Lambda 表达式，从此我们的代码可以清爽简洁，而且看起来也很好理解：箭头的左边是形参，右边是函数体，整个 Lambda 表达式就是一个函数（就是数学中的函数）。 更多 Lambda 表达式的信息可以查看《Java 8新特性：lambda表达式》——廖雪峰。 如何使用安利了这么多 Lambda 表达式的优点，但由于众所周知的某些原因，Android 中的 Java 版本被限定在了 1.6 以下，所以也就没办法使用那么好的 Lambda 表达式了。 但 Lambda 表达式这么好，你不让我用我就不用了么？我偏要用！ 好的，有以下两种方式都可以为我们开启 Lambda 表达式，我们只需要任选其一就可以了。 RetroLambdaRetroLambda 的 Gradle 插件让我们可以在 Android 中使用 Lambda 表达式，那么我们看看如何使用它吧。 Project我们需要在项目目录下的build.gradle中加入它的classpath 123456789101112buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:2.1.0-alpha4' classpath 'me.tatarka:gradle-retrolambda:3.2.5' // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files &#125;&#125; 在dependencies中加入classpath &#39;me.tatarka:gradle-retrolambda:3.2.5&#39; app module编辑build.gradle启用插件，并把 Java 语法调整到 1.8 在顶部启用插件 1apply plugin: 'me.tatarka.retrolambda' 在android中加入以下代码段启用 1.8 的语法 1234compileOptions &#123; sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8&#125; Enjoy it !~ jackjack 是 Java Android Compile Kit 的缩写，它是 Google 为 Android 推出的一个编译工具包，它的原理在这里就不详述了。它有一个特点就是可以使用 Lambda 表达式，而且配置十分简单。 准备使用 jack 我们必须要把buildTools升级到24以上，我已经升级到了24 RC。 使用编辑 app 模块中的build.gradle，在defaultConfig中加一行useJack true，然后在android中添加如下一段代码 1234compileOptions &#123; sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8&#125; 然后就好了，是不是非常简单呢~ 总结在 Java 1.8 中的 Lambda 表达式实际上只是一个语法糖，它可以帮助我们简化代码，并且表述地更佳清晰。但 Java 目前来说并不是一门有函数式特性的编程语言，而且短期内不会加入函数式特性。如果你想使用一门拥有函数式特性的语言来写 Android Application 的话，可以考虑一下 Kotlin。","categories":[{"name":"技术","slug":"技术","permalink":"https://loshine.me/categories/技术/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://loshine.me/tags/Java/"},{"name":"Android","slug":"Android","permalink":"https://loshine.me/tags/Android/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://loshine.me/categories/技术/"}]},{"title":"Anroid中的自定义View绘制","slug":"custom-view-in-android","date":"2016-03-25T16:09:00.000Z","updated":"2016-11-16T17:09:19.000Z","comments":true,"path":"2016/03/26/custom-view-in-android/","link":"","permalink":"https://loshine.me/2016/03/26/custom-view-in-android/","excerpt":"","text":"虽然我们在开发中基本可以用 Android 自带的各种控件实现绝大多数的功能，但难以避免还是有一些需求是自带的控件无法实现的。这个时候我们通常会想到去 Github 上寻找开源控件，但有的东西是有成熟的实现如：ViewPager 的 Indicator。而有的就没那么容易找到了。 还有就是虽然我们平时的一些需求可以使用图片资源代替，但过多的图片资源不仅会使得应用体积增大，还会使得加载的过程中消耗不少的系统资源（内存以及 CPU）—— 我曾经就这么干过，至少这种方法做东西很快（但也很坑）。 这个时候我们就应该想到自定义 View 了，下面就讲讲我在学习自定义 View 的一些心得体会吧。 View绘制流程View 的绘制是从 ViewRoot 的performTraversals()方法开始的，其执行过程可简单概括为根据之前所有设置好的状态，判断是否需要计算视图大小（measure）、是否需要重新安置视图的位置（layout），以及是否需要重绘（draw）视图，其流程图如下所示： 而我们今天讲的自定义 View 的绘制，主要就是在是否需要重新 draw 这一步来实现。 三个绘图工具类简介要在自定义 View 中进行重新绘制，我们首先需要了解一下 Android 中的三个重要的绘图工具类，它们就是Paint(画笔)、Canvas(画布)以及Path(路径)。当然其实不仅仅只有这三个可以作用于画图和图像处理，但它们是最基础的。 PaintPaint 就是画笔，在 Android 图形绘制的时候，我们就好像真的有一个人拿着画笔把图像画出来一样，所以画笔这个类也给了我们和现实世界作画的时候一样的一些设定。 我们可以通过 Paint 来设定线宽(就像现实中画笔的粗细)、颜色(颜料)、透明度以及填充风格等。 我们可以通过它的构造函数来新建一个画笔 1Paint paint = new Paint(); 然后对它进行一些设定 1234567891011121314151617181920212223242526272829303132paint.setARGB(255, 255, 0, 0); // 设置 ARGB 颜色 intpaint.setAlpha(0); // 设置透明度 intpaint.setColor(getResources().getColor(android.R.color.black)); // 设置颜色paint.setAntiAlias(true); // 开启抗锯齿paint.setDither(true); // 开启抖动处理，使得绘制的图形更清晰paint.setFilterBitmap(true); // 滤掉对Bitmap图像的优化操作,加快显示速度paint.setMaskFilter(maskFilter); // 添加滤镜paint.setColorFilter(colorFilter); // 设置颜色过滤器paint.setPathEffect(pathEffect); // 设置路径效果(如虚线等)paint.setShader(shader); // 设置渐变效果paint.setShadowLayer(2, 2, 2, Color.GRAY); // 半径2,x,y 距离为2，颜色灰色的阴影paint.setStyle(Paint.Style.FILL_AND_STROKE); // 画笔样式(内部、边框还是both，画封闭图形的时候比较重要)paint.setStrokeCap(Paint.Cap.SQUARE); // 方形笔刷paint.setStrokeJoin(Paint.Join.MITER); // 各图形的结合方式paint.setStrokeWidth(2); // 画笔粗细paint.setXfermode(xfermode); // 图形重叠时的处理方式paint.setFakeBoldText(true); // 模拟粗体paint.setSubpixelText(true); // 提升文字在 LCD 的显示效果paint.setTextAlign(Paint.Align.CENTER); // 文字对齐方向paint.setTextScaleX(0.5); // 文字 X 轴缩放paint.setTextSize(40); // 文字大小paint.setTextSkewX(30); // 文字倾斜度paint.setTypeface(Typeface.SANS_SERIF); // 字体风格paint.setUnderlineText(true); // 下划线paint.setStrikeThruText(true); // 删除线paint.setStrokeJoin(Paint.Join.ROUND); // 结合处风格paint.setStrokeMiter(30); // 画笔倾斜度paint.setStrokeCap(Paint.Cap.ROUND); // 拐角处风格paint.ascent(); // baseline之上至字符最高处的距离paint.descent(); // baseline之下至字符最低处的距离paint.clearShadowLayer(); // 清除阴影// 等等 但我们光有画笔还是不够的，我们至少还需要画布(Canvas)才可以真正开始作画呢。 CanvasCanvas 就是画布，我们有了画笔和画布就可以开始作画(图形绘制)了。 我们有两种创建 Canvas 的方法： 12Canvas canvas = new Canvas();Canvas canvasByBitmap = new Canvas(bitmap); 其中传入 Bitmap 的方法会将 Bitmap 作为画布的背景。 下面是常用的drawXXX()方法，它们被用于绘制不同的图形 12345678910canvas.drawRect(new RectF(0, 0, 100, 100), mPaint); // 绘制一个方形canvas.drawRect(0, 0, 100, 100, mPaint); // 绘制一个方形canvas.drawPath(path, paint); // 绘制一个路径canvas.drawBitmap(bitmap, src, dst, mPaint); // 第二和第三个参数是 Rectcanvas.drawLine(0, 0, 100, 100, mPaint); // 画线canvas.drawPoint(100, 20, mPaint); // 画点canvas.drawText(\"这是一段文字\", 0, 0, mPaint); // 画文字canvas.drawOval(new RectF(0, 0, 100, 200), mPaint); // 画方形的内切椭圆canvas.drawCircle(300, 300, 100, mPaint); // 画圆canvas.drawArc(new RectF(0, 0, 100, 100), 0, 30, true, mPaint); // 一个矩形内的扇形 还有clipXXX()方法，它们是裁剪一块新的区域用于绘图，这里就不详细说明了。 save()和restore()方法用来保存和恢复 Canvas 的状态，简单而言就是一个存档，一个恢复存档。 还有就是三个变换方法：translate(平移)、scale(缩放)以及rotate(旋转)了，它们可以控制画布的一些动作，就好像我们真实世界中作画的时候对画布的一些动作一样(除了缩放，2333)。 Path其实在有了上面两个类之后我们就已经可以开始绘制了，但还是先把 Path 也介绍完毕之后再开始真实案例吧。 Path 就是路径，有点像我们在初中数学中学习函数的时候，可以根据几个点确认画出一个函数的图形。 下面是一些常用的方法： 123456789101112path.addArc(new RectF(0, 0, 100, 100), 0, 30); // 添加一段圆弧path.addCircle(300, 300, 100, Path.Direction.CW); // 顺时针圆path.addOval(rectF, Path.Direction.CCW); // 逆时针椭圆path.addRect(rectF, Path.Direction.CW); // 添加矩形path.addRoundRect(rectF, &#123;5, 5, 5, 5&#125;, path.Direction.CW); // 添加圆角矩形path.isEmpty(); // 是否无路径path.transform(matrix); // 矩阵变换path.moveTo(100, 100); // 移动画笔而不绘制path.lineTo(300, 300); // 默认从(0，0)开始绘制,可以用 moveTo 移动起始点,调用 canvas.drawPath(path, paint) 绘制path.quadTo(x1, y1, x2, y2); // 绘制贝塞尔曲线,三点(起始点默认(0, 0))确认path.rCubicTo(x1, y1, x2, y2, x3, y3); // 多一个控制点的贝塞尔曲线path.arcTo(rectF, 0, 50); // 圆弧 开始绘制介绍完了三个绘制 UI 的基础类，那么我们现在来动手试试吧。难度从低到高，循序渐进完成自定义 View 中复杂图形的绘制。 我们自定义一个 View 并且要重新绘制的话，我们只需要新建一个类继承 View 并且实现onDraw(Canvas canvas)即可，View 会调用子类实现的onDraw完成绘制。 那么我们接下来的示例就只列出onDraw方法和对应的效果图了。 简单图形矩形123456@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); // 在构造函数中初始化画笔并设置为黑色 canvas.drawRect(0, 0, 100, 200, mPaint);&#125; 线段12345@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawLine(0, 0, 100, 200, mPaint);&#125; 圆形12345@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawCircle(100, 100, 100, mPaint);&#125; 画布底色12345@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawColor(getResources().getColor(android.R.color.darker_gray));&#125; 复杂图形刻度尺1234567891011121314151617181920212223@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); // 防止数字0出界 canvas.translate(0, 50); for (int i = 0; i &lt;= 100; i++) &#123; if (i % 10 == 0) &#123; // 带有数字的长刻度 canvas.drawLine(0, 0, 70, 0, mPaint); // 画文字 canvas.drawText(String.format(Locale.CHINESE, \"%d\", i / 10), 100, 10, mPaint); &#125; else if (i % 5 == 0) &#123; // 每隔5的中等长度的刻度 canvas.drawLine(0, 0, 40, 0, mPaint); &#125; else &#123; // 其它小刻度 canvas.drawLine(0, 0, 30, 0, mPaint); &#125; // 每个刻度画完之后位移 canvas.translate(0, 15); &#125;&#125; 手表表盘12345678910111213141516171819@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); // 绘制外圈圆 canvas.drawCircle(400, 400, 400, mPaint); // 绘制分针和时针 canvas.drawLine(400, 400, 400, 200, mPaint); canvas.drawLine(400, 400, 550, 400, mPaint); // 绘制刻度和文字 for (int i = 0; i &lt; 12; i++) &#123; canvas.drawLine(400, 0, 400, 10, mPaint); canvas.drawText(String.format(Locale.CHINESE, \"%d\", i == 0 ? 12 : i), 400, 100, mTextPaint); // 旋转画布 canvas.rotate(30, 400, 400); &#125;&#125; 总结其实 Android 中的图形绘制基本就是靠这三个类扩展变化而来，掌握了它们的使用方式我们也就可以定义各种各样的好看的自定义控件了。 那么我们掌握了绘制之后，我们还要考虑的就是自定义 View 的测量了，我会在之后再写一篇博文来总结我学习自定义 View 的测量的一些经验，感谢观看（虽然并不会有多少人看……）。","categories":[{"name":"技术","slug":"技术","permalink":"https://loshine.me/categories/技术/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://loshine.me/tags/Android/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://loshine.me/categories/技术/"}]},{"title":"博客迁移到 Hexo","slug":"migrate-blog-to-hexo","date":"2016-03-22T09:09:00.000Z","updated":"2016-11-16T17:09:19.000Z","comments":true,"path":"2016/03/22/migrate-blog-to-hexo/","link":"","permalink":"https://loshine.me/2016/03/22/migrate-blog-to-hexo/","excerpt":"","text":"Github Pages 服务的 Jekyll 升级了，干脆我就趁着这次机会把博客迁移到 Hexo 好了。 Hexo 是 Node.js 的一个静态博客系统，相比起 Ruby 实现的 Jekyll，它生成的速度更快而且更加现代化。当然最重要的就是对前端工程师更友好啦，毕竟是用 javascript 写的嘛 使用 Hexo 和 Jekyll 的不同点在于 Hexo 是生成静态文件后上传到 Github Pages 服务上，而 Jekyll 是上传源码然后在服务器上生成静态文件。 如何使用Hexo安装Hexo 安装 Node.js 安装 Hexo 1npm install hexo-cli -g 生成静态博客项目只需要输入以下命令就会生成一个静态博客项目 123hexo init blogcd blognpm install 然后等待 npm 安装完成 运行博客输入以下命令，然后就可以在浏览器地址栏中输入http://localhost:4000/打开博客 1hexo server 编写文章在source/_posts文件夹下放入对应格式的 markdown 文件，hexo 就会根据模板将其渲染为对应格式的 html 静态文件。 从Jekyll迁移迁移文章把_posts文件夹内的所有文件复制到source/_posts文件夹，并在_config.yml中修改new_post_name参数。 1new_post_name: :year-:month-:day-:title.md 文章格式修改Jekyll 特定的Front-matter需要删掉并且替换为对应的 Hexo 的Front-matter，并且文章的 markdown 格式可能需要修改 部署到 Github Pages和 Jekyll 类似，我们还是需要一个username.github.io的项目。但和 Jekyll 不同的是我们需要把生成的静态文件部署上去而不是将 markdown 文件部署上去。 在本地输入 123hexo g# 或者hexo generate 即可在本地生成静态页面，然后打开config.yml，修改为自己的项目信息就可以了 1234deploy: type: git repo: git@github.com:loshine/loshine.github.io.git branch: master 高级设置config.yml文件有许多的可配置选项，可以参照这里设置 主题默认情况下使用的是 landscape 主题，我们也可以在这里挑选主题 总结其实博客迁移完毕已经挺久了，我终于在今天（2016-03-22）想起来把这个过程记录下来了，也可以给其他需要迁移的人一个参考吧。","categories":[{"name":"技术","slug":"技术","permalink":"https://loshine.me/categories/技术/"}],"tags":[{"name":"github","slug":"github","permalink":"https://loshine.me/tags/github/"},{"name":"github-pages","slug":"github-pages","permalink":"https://loshine.me/tags/github-pages/"},{"name":"Hexo","slug":"Hexo","permalink":"https://loshine.me/tags/Hexo/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://loshine.me/categories/技术/"}]},{"title":"Kotlin与DataBinding协作","slug":"android-databinding-with-kotlin","date":"2016-03-08T13:23:10.000Z","updated":"2016-11-16T17:09:19.000Z","comments":true,"path":"2016/03/08/android-databinding-with-kotlin/","link":"","permalink":"https://loshine.me/2016/03/08/android-databinding-with-kotlin/","excerpt":"","text":"DataBinding 是 Google 爹地为我们这群苦逼的 Android 开发者推出的 MVVM 框架。本文解决 Kotlin 和 DataBindin 共用时报错的问题。 如下修改即可app 的 build.gradle 中添加如下部分 1234567dependencies &#123; // ... kapt 'com.android.databinding:compiler:1.0-rc5'//改为对应版本&#125;kapt &#123; generateStubs = true&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://loshine.me/categories/技术/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://loshine.me/tags/Android/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://loshine.me/tags/Kotlin/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://loshine.me/categories/技术/"}]},{"title":"Kotlin中的委托属性","slug":"delegated-properties-in-kotlin","date":"2016-03-01T01:29:34.000Z","updated":"2016-11-16T17:09:19.000Z","comments":true,"path":"2016/03/01/delegated-properties-in-kotlin/","link":"","permalink":"https://loshine.me/2016/03/01/delegated-properties-in-kotlin/","excerpt":"","text":"Kotlin 是 Jetbrain 推出的一门运行在 JVM 上的语言，它结合了面向对象以及函数式语言的特性，超甜的语法糖以及来自知名 IDE 大厂 Jetbrain 的出身让它初一面世就广受瞩目，特别是在 Android 开发社区中。它相比起 Java 拥有了许许多多的优秀特性，并且几乎每一个新特性都对应解决了 Java 开发时的痛苦之处，本篇文章主要讲解 Kotlin 中的委托属性这一特性。 委托属性(Delegated Properties)我们先看看官网的定义： 有一些种类的属性，虽然我们可以在每次需要的时候手动实现它们，但是如果能够把他们之实现一次 并放入一个库同时又能够一直使用它们那会更好。例如： 延迟属性（lazy properties）: 数值只在第一次被访问的时候计算。 可控性（observable properties）: 监听器得到关于这个特性变化的通知， 把所有特性储存在一个映射结构中，而不是分开每一条。 为了支持这些(或者其他)例子，Kotlin 采用 委托属性。 简言之就是简化手动实现的属性，将其抽象出一个库。 如何使用定义一个委托Kotlin 中有两种属性：用var修饰的可变属性和由val修饰的只读属性。由val修饰的只读属性使用的委托需要实现ReadOnlyProperty，而var修饰的可变属性则需要实现ReadWriteProperty 在调用被委托的属性的getter和setter时，对应操作会被委托给getValue()以及setValue()。 如实现一个最简单的委托Delegate： 123456789class Delegate &#123; operator fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): String &#123; return \"$thisRef, thank you for delegating '$&#123;property.name&#125;' to me!\" &#125; operator fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: String) &#123; println(\"$value has been assigned to '$&#123;property.name&#125; in $thisRef.'\") &#125;&#125; 使用定义好的委托属性语法为val/var &lt;property name&gt;: &lt;Type&gt; by &lt;expression&gt; 123class Example &#123; var p: String by Delegate()&#125; by后面的是委托表达式，我们调用这个对象并使用属性： 1234val e = Example()println(e.p)e.p = \"NEW\" 打印结果为： 12Example@33a17727, thank you for delegating 'p' to me!NEW has been assigned to 'p' in Example@33a17727. 如上可知，thisRef对应的是拥有该被委托属性的对象实例，property则是属性，value是调用setter时的传入值。 实例讲解lazy 懒加载Kotlin 标准库自带的懒加载委托，在属性第一次被使用时才进行初始化。 函数lazy()接受一个 lambda 然后返回一个可以作为委托Lazy&lt;T&gt; 实例来实现延迟属性: 第一个调用getter执行变量传递到lazy()并记录结果, 后来的getter调用只会返回记录的结果。 123456789val lazyValue: String by lazy &#123; println(\"computed!\") \"Hello\"&#125;fun main(args: Array&lt;String&gt;) &#123; println(lazyValue) println(lazyValue)&#125; 其打印结果： 123computed! # 第一次使用时先初始化Hello # getterHello # 后续都只会调用 getter 懒加载委托在实际编码中应用十分广泛，比如 Android 中我们可以把很多在OnCreate中需要进行的初始化操作使用懒加载委托来实现。 使用委托操作 SharedPreferences本例出自《Kotlin for Android Developer》，使用了when表达式和委托属性巧妙地使得SharedPrefences的读写变得十分简便 123456789101112131415161718192021222324252627282930313233343536class Preference&lt;T&gt;(val context: Context, val name: String, val default: T) : ReadWriteProperty&lt;Any?, T&gt; &#123; val prefs by lazy &#123; context.getSharedPreferences(\"default\", Context.MODE_PRIVATE) &#125; override fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): T &#123; return findPreference(name, default) &#125; override fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: T) &#123; putPreference(name, value) &#125; private fun &lt;U&gt; findPreference(name: String, default: U): U = with(prefs) &#123; val res: Any = when (default) &#123; is Long -&gt; getLong(name, default) is String -&gt; getString(name, default) is Int -&gt; getInt(name, default) is Boolean -&gt; getBoolean(name, default) is Float -&gt; getFloat(name, default) else -&gt; throw IllegalArgumentException(\"This type can be saved into Preferences\") &#125; res as U &#125; private fun &lt;U&gt; putPreference(name: String, value: U) = with(prefs.edit()) &#123; when (value) &#123; is Long -&gt; putLong(name, value) is String -&gt; putString(name, value) is Int -&gt; putInt(name, value) is Boolean -&gt; putBoolean(name, value) is Float -&gt; putFloat(name, value) else -&gt; throw IllegalArgumentException(\"This type can be saved into Preferences\") &#125;.apply() &#125;&#125; 在代码中我们可以如下使用 12345678class WhateverActivity : Activity() &#123; var aInt: Int by Preference(this, \"aInt\", 0) fun whatever() &#123; println(aInt) // 会从 SharedPreference 取这个数据 aInt = 9 // 会将这个数据写入 SharedPreference &#125;&#125; 从此操作SharedPreferences变得如此简单 ~ 简单实现一个 KotterKnifeKotterKnife 是一个 Android 控件依赖注入框架，使用它可以很方便地初始化 Activity、Fragment、View 等的控件。 KotterKnife 的实现原理就是使用了委托属性，下面我就使用委托属性简单实现一个 View 注入功能 实现我们平时是这样初始化 View 的 123456override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) val textView = findViewById(R.id.text_view) as TextView&#125; 考虑到通常我们在onCreate方法中将其初始化，我们可以用 lazy 委托，在第一次使用该控件的时候才将其初始化，这样可以减少不必要的内存消耗。 123val mTextView by lazy &#123; findViewById(R.id.text_view) as TextView&#125; 对其抽取简化 1234567@Suppress(\"UNCHECKED_CAST\")fun &lt;V : View&gt; Activity.bindView(id: Int): Lazy&lt;V&gt; = lazy &#123; viewFinder(id) as V&#125;private val Activity.viewFinder: Activity.(Int) -&gt; View? get() = &#123; findViewById(it) &#125; 之后我们就可以在 Activity 中这样注入 View 了 1val mTextView by bindView&lt;TextView&gt;(R.id.text_view) 如上实现了类似 KotterKnife 的控件注入功能，当然 KotterKnife 中还有更加强大的可选绑定以及数组绑定，本文中我们就不细说了，有兴趣的读者可以阅读 KotterKnife源码。 小结本文分析了 Kotlin 中的委托属性，并对其实际应用做了示例分析。委托属性是 Kotlin 语言的一个特性，灵活使用可以解决实际编码中的许多问题，减少大量重复代码，而由于其与属性的getter、setter直接绑定所以使用起来也十分灵活方便。 总而言之：这真是极好的。","categories":[{"name":"技术","slug":"技术","permalink":"https://loshine.me/categories/技术/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://loshine.me/tags/Android/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://loshine.me/tags/Kotlin/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://loshine.me/categories/技术/"}]},{"title":"Kotlin中实现Parcelable","slug":"implements-parcelable-in-kotlin","date":"2015-10-17T03:03:59.000Z","updated":"2016-11-16T17:09:19.000Z","comments":true,"path":"2015/10/17/implements-parcelable-in-kotlin/","link":"","permalink":"https://loshine.me/2015/10/17/implements-parcelable-in-kotlin/","excerpt":"","text":"在Android中，如果需要序列化对象可以选择实现 Serializable 或 Parceable。如果是在使用内存的情况下，Parcelable 的效率比 Serializable 高。但 Parcelable 不能被持久化存储，此时还是需要实现 Serializable。 Java实现首先我们看一个普通的 JavaBean 1234567891011121314151617181920212223242526272829303132333435/** * 帖子实体类 * &lt;p/&gt; * Created by Loshine on 15/9/8. */public class PostEntity &#123; /** * 帖子标题 */ private String name; /** * 帖子类别 */ private String category; /** * 帖子链接 */ private String link; /** * 评论数 */ private String comments; /** * 发布者 */ private String announcer; /** * 最新回复时间 */ private String replyTime; /* * 省略 getter setter... */ 其中的代码都是 JavaBean 的属性以及 getter、setter 如果其实现 Parcelable，则是这样的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** * 帖子实体类 * &lt;p/&gt; * Created by Loshine on 15/9/8. */public class PostEntity implements Parcelable &#123; /** * 帖子标题 */ private String name; /** * 帖子类别 */ private String category; /** * 帖子链接 */ private String link; /** * 评论数 */ private String comments; /** * 发布者 */ private String announcer; /** * 最新回复时间 */ private String replyTime; /* * 省略 getter setter... */ @Override public int describeContents() &#123; return 0; &#125; @Override public void writeToParcel(Parcel dest, int flags) &#123; dest.writeString(this.name); dest.writeString(this.category); dest.writeString(this.link); dest.writeString(this.comments); dest.writeString(this.announcer); dest.writeString(this.replyTime); &#125; public PostEntity() &#123; &#125; protected PostEntity(Parcel in) &#123; this.name = in.readString(); this.category = in.readString(); this.link = in.readString(); this.comments = in.readString(); this.announcer = in.readString(); this.replyTime = in.readString(); &#125; public static final Parcelable.Creator&lt;PostEntity&gt; CREATOR = new Parcelable.Creator&lt;PostEntity&gt;() &#123; public PostEntity createFromParcel(Parcel source) &#123; return new PostEntity(source); &#125; public PostEntity[] newArray(int size) &#123; return new PostEntity[size]; &#125; &#125;; 在实现Parcelable的时候我们需要重写两个方法 public void writeToParcel(Parcel dest, int flags) public int describeContents() 其中describeContents只需要返回 0 即可 writeToParcel方法中我们把需要序列化的属性使用writeXXX的方式写入 Parcel 。 之后是 CREATOR 对象，这个对象负责从 Parcel 中读取对象，所以我们需要重写其方法来读取对象 123456789101112131415161718protected PostEntity(Parcel in) &#123; this.name = in.readString(); this.category = in.readString(); this.link = in.readString(); this.comments = in.readString(); this.announcer = in.readString(); this.replyTime = in.readString(); &#125; public static final Parcelable.Creator&lt;PostEntity&gt; CREATOR = new Parcelable.Creator&lt;PostEntity&gt;() &#123; public PostEntity createFromParcel(Parcel source) &#123; return new PostEntity(source); &#125; public PostEntity[] newArray(int size) &#123; return new PostEntity[size]; &#125; &#125;; 这一段就是其实现方式，可见主要是将对象从 Parcel 中读取出来。 Kotlin实现看过了冗长的 Java 实现方式，我们来看看kotlin是如何实现的吧。 首先使用插件将其转换为 Kotlin 文件，并修改其中的错误 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class PostEntity : Parcelable &#123; /** * 帖子标题 */ var name: String? = null /** * 帖子类别 */ var category: String? = null /** * 帖子链接 */ var link: String? = null /** * 评论数 */ var comments: String? = null /** * 发布者 */ var announcer: String? = null /** * 最新回复时间 */ var replyTime: String? = null override fun describeContents(): Int &#123; return 0 &#125; override fun writeToParcel(dest: Parcel, flags: Int) &#123; dest.writeString(this.name) dest.writeString(this.category) dest.writeString(this.link) dest.writeString(this.comments) dest.writeString(this.announcer) dest.writeString(this.replyTime) &#125; constructor() &#123; &#125; protected constructor(`in`: Parcel) &#123; this.name = `in`.readString() this.category = `in`.readString() this.link = `in`.readString() this.comments = `in`.readString() this.announcer = `in`.readString() this.replyTime = `in`.readString() &#125; companion object &#123; val CREATOR: Parcelable.Creator&lt;PostEntity&gt; = object : Parcelable.Creator&lt;PostEntity&gt; &#123; override fun createFromParcel(source: Parcel): PostEntity &#123; return PostEntity(source) &#125; override fun newArray(size: Int): Array&lt;PostEntity?&gt; &#123; return arrayOfNulls(size) &#125; &#125; &#125;&#125; 这就是 Kotlin 实现 Parcelable 的方式了 优化经过插件转化的 kotlin 代码其实使用的还是 java 的方式和 java 的思想，我们可以将其完全转化为 kotlin 的方式并对其优化 首先把其转化为数据类，这样会自动为我们生成 equals()/hashCode() toString() componentN() copy() 我们只需要将其改为这样 12345678910111213141516171819202122232425262728293031323334353637383940414243data class PostEntity(var name: String? = null, /* 帖子标题*/ var category: String? = null, /* 帖子类别 */ var link: String? = null, /* 帖子链接 */ var comments: String? = null, /* 评论数 */ var announcer: String? = null, /* 发布者 */ var replyTime: String? = null /* 最新回复时间 */) : Parcelable &#123; override fun describeContents(): Int &#123; return 0 &#125; override fun writeToParcel(dest: Parcel, flags: Int) &#123; dest.writeString(this.name) dest.writeString(this.category) dest.writeString(this.link) dest.writeString(this.comments) dest.writeString(this.announcer) dest.writeString(this.replyTime) &#125; protected constructor(`in`: Parcel) : this() &#123; this.name = `in`.readString() this.category = `in`.readString() this.link = `in`.readString() this.comments = `in`.readString() this.announcer = `in`.readString() this.replyTime = `in`.readString() &#125; companion object &#123; val CREATOR: Parcelable.Creator&lt;PostEntity&gt; = object : Parcelable.Creator&lt;PostEntity&gt; &#123; override fun createFromParcel(source: Parcel): PostEntity &#123; return PostEntity(source) &#125; override fun newArray(size: Int): Array&lt;PostEntity?&gt; &#123; return arrayOfNulls(size) &#125; &#125; &#125;&#125; 再之后观察发现，所有的 Parcelable 都需要有一个 CREATOR 123456789101112companion object &#123; val CREATOR: Parcelable.Creator&lt;PostEntity&gt; = object : Parcelable.Creator&lt;PostEntity&gt; &#123; override fun createFromParcel(source: Parcel): PostEntity &#123; return PostEntity(source) &#125; override fun newArray(size: Int): Array&lt;PostEntity?&gt; &#123; return arrayOfNulls(size) &#125; &#125;&#125; 此处使用了 Kotlin 的伴生对象，使得调用 CREATOR 类似于 Java 中的静态属性 可以使用 Kotlin 的函数式编程特性抽取 新建文件ParcelableExt.kt 12345public inline fun createParcel&lt;reified T : Parcelable&gt;(crossinline createFromParcel: (Parcel) -&gt; T?): Parcelable.Creator&lt;T&gt; = object : Parcelable.Creator&lt;T&gt; &#123; override fun createFromParcel(source: Parcel): T? = createFromParcel(source) override fun newArray(size: Int): Array&lt;out T?&gt; = arrayOfNulls(size) &#125; 此处使用了 Kotlin 的内联函数，然后我们就可以将 PostEntity 精简为如下 12345678910111213141516171819202122232425262728293031323334data class PostEntity(var name: String? = null, /* 帖子标题*/ var category: String? = null, /* 帖子类别 */ var link: String? = null, /* 帖子链接 */ var comments: String? = null, /* 评论数 */ var announcer: String? = null, /* 发布者 */ var replyTime: String? = null /* 最新回复时间 */) : Parcelable &#123; override fun describeContents(): Int &#123; return 0 &#125; override fun writeToParcel(dest: Parcel, flags: Int) &#123; dest.writeString(this.name) dest.writeString(this.category) dest.writeString(this.link) dest.writeString(this.comments) dest.writeString(this.announcer) dest.writeString(this.replyTime) &#125; protected constructor(`in`: Parcel) : this() &#123; this.name = `in`.readString() this.category = `in`.readString() this.link = `in`.readString() this.comments = `in`.readString() this.announcer = `in`.readString() this.replyTime = `in`.readString() &#125; companion object &#123; val CREATOR = createParcel &#123; PostEntity(it) &#125; &#125;&#125; 总结虽然可以直接将 Java 文件转化为 Kotlin 文件，但这样毕竟没有办法学习到 Kotlin 的精髓 使用一门语言就应该按照这门语言的编码风格以及规范去实现，这样才会让我们的学习更加有效率且养成良好的编码习惯 Kotlin 是一门典型的函数式编程语言，学习它的风格有利于我们了解函数式编程思想 在实现 Parceable 时我们使用了 Kotlin 的几个特性 数据类 二级构造函数 内联函数 查阅官方文档完成的同时我也学会了新的姿势知识，想一想也有点小激动呢","categories":[{"name":"技术","slug":"技术","permalink":"https://loshine.me/categories/技术/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://loshine.me/tags/Android/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://loshine.me/tags/Kotlin/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://loshine.me/categories/技术/"}]},{"title":"打磨真正属于自己的输入法-RIME","slug":"rime","date":"2015-09-12T04:59:57.000Z","updated":"2016-11-16T17:09:19.000Z","comments":true,"path":"2015/09/12/rime/","link":"","permalink":"https://loshine.me/2015/09/12/rime/","excerpt":"","text":"很久之前就发现了 RIME 这个输入法，但因为在 windows 下的种种不便，把玩了一段时间后终于还是将之打入箱底。近期由于换上了 mac 作为主力开发机，于是又将其从箱底翻出，仔细把玩打磨一段时间之后已经十分跟手了，于是乎在这里记录一下打磨过程。 简介RIME，全称是中州韵输入法引擎，是由佛振先生开发的跨平台开源输入法。 它在不同平台上有不同的名字： Windows：小狼毫 Weasel Mac OS X： 鼠须管 Squirrel Linux：ibus-rime or fcitx-rime 其内置的输入方案包括 朙月拼音 朙月拼音 语句流 朙月拼音 简化字模式 朙月拼音 臺灣正體模式 地球拼音 dì qiú pīn yīn 注音 注音 臺灣正體模式 粵拼 倉頡五代 倉頡 快打模式 速成 五笔86 五笔拼音混合輸入 自然碼雙拼 微軟雙拼 智能ABC雙拼 小鶴雙拼 吳語上海話（新派） 吳語上海話（老派） 中古漢語三拼 中古漢語全拼 X-SAMPA 國際音標 emoji表情 再由于其强大的可定制性，也有许多爱好者为其制作了如下输入方案 英文 日语 山人全息码 …… 它也集成了许多好看的主题，当然你也可以自定义自己喜欢的配色主题。 安装前往下载地址选择对应的版本下载，Mac用户选择鼠须管 Squirrel即可。 下载完成之后，解压zip压缩包，然后打开Squirrel-versioncode.pkg按步骤安装即可。 使用 Mac用户在输入源中添加鼠须管 按⌘ + Space切换输入法到鼠须管 按下Ctrl + `，依次选择 2、4 切换到简体输入 Enjoy it！ 自定义点击右上角输入法按钮，选择用户设定，可以看到所有鼠须管的配置文件。鼠须管的配置文件都是yaml格式的，我们如果想要自定义，可以新建一个*.custom.yaml对其进行修改，这样可以防止更新程序的时候修改内容被覆盖，也方便同步。 输入方案新建一个default.custom.yaml文件，将如下内容复制进去，然后根据自己的需求注释或者去掉注释即可。在完成之后，不要忘记重新部署一下，之后就可以使用Ctrl + `切换输入方案了。 12345678910111213141516171819202122232425patch: schema_list: - schema: luna_pinyin # 朙月拼音 - schema: luna_pinyin_fluency # 朙月拼音 语句流# - schema: luna_pinyin_simp # 朙月拼音 简化字模式# - schema: luna_pinyin_tw # 朙月拼音 臺灣正體模式 - schema: terra_pinyin # 地球拼音 dì qiú pīn yīn# - schema: bopomofo # 注音# - schema: bopomofo_tw # 注音 臺灣正體模式# - schema: jyutping # 粵拼# - schema: cangjie5 # 倉頡五代# - schema: cangjie5_express # 倉頡 快打模式# - schema: quick5 # 速成# - schema: wubi86 # 五笔86 - schema: wubi_pinyin # 五笔拼音混合輸入# - schema: double_pinyin # 自然碼雙拼# - schema: double_pinyin_mspy # 微軟雙拼# - schema: double_pinyin_abc # 智能ABC雙拼# - schema: double_pinyin_flypy # 小鶴雙拼# - schema: wugniu # 吳語上海話（新派）# - schema: wugniu_lopha # 吳語上海話（老派）# - schema: sampheng # 中古漢語三拼# - schema: zyenpheng # 中古漢語全拼# - schema: ipa_xsampa # X-SAMPA 國際音標 - schema: emoji # emoji表情 外观新建一个squirrel.custom.yaml文件，向其中写入如下内容，然后根据自己的需求修改。 12345678910111213141516171819202122232425# 適用於【鼠鬚管】0.9.13+# 位置：~/Library/Rime/squirrel.custom.yaml# 用法：想要哪項生效，就刪去該行行首的#字符，但注意保留用於縮進的空格patch:# us_keyboard_layout: true # 鍵盤選項：應用美式鍵盤佈局# show_notifications_when: growl_is_running # 狀態通知，默認裝有Growl時顯示，也可設爲全開（always）全關（never）# style/horizontal: true # 候選窗横向顯示# style/inline_preedit: false # 非內嵌編碼行# style/font_face: \"儷黑 Pro\" # 我喜歡的字體名稱# style/font_point: 21 # 字號# style/corner_radius: 10 # 窗口圓角半徑# style/border_height: 0 # 窗口邊界高度，大於圓角半徑才有效果# style/border_width: 0 # 窗口邊界寬度，大於圓角半徑才有效果# style/color_scheme: luna # 選擇配色方案# 註：預設的配色方案及代碼（指定爲 style/color_scheme ）# 碧水 - aqua# 青天 - azure# 明月 - luna# 墨池 - ink# 孤寺 - lost_temple# 暗堂 - dark_temple# 星際我爭霸 - starcraft# 谷歌 - google 主题如上一部分，只能设置默认的主题。虽然默认的主题也挺不错的，但是我们也可以定制自定义的主题。 还是在squirrel.custom.yaml中，在刚刚加入的内容后面加入如下内容 1234567891011preset_color_schemes/textflow: author: \"name &lt;name@gmail.com&gt;\" back_color: 0xFFFFFF #背景 border_color: 0xE0B693 #边框 candidate_text_color: 0x000000 #非第一候选项 hilited_back_color: 0xEBECED #拼音串高亮背景 hilited_candidate_back_color: 0xFFFFFF #第一候选项背景 hilited_candidate_text_color: 0xF57C75 #第一候选项 hilited_text_color: 0xFF6666 #拼音串高亮 name: Textflow text_color: 0x000000 #拼音串 然后启用这个主题就可以了 如果你想要更多的配色，可以参照RIME吧：配色方案专帖 生僻字乱码生僻字乱码是因为默认字库中不含生僻字所导致的，解决方案就是为其设置字库齐全的备用字体。 一般的选择是「花园明朝」，下载下来安装好之后，将 外观 这一步中的 1style/font_face: \"儷黑 Pro\" # 我喜歡的字體名稱 改为 1style/font_face: \"PingFang SC,HanaMinA\" # 我喜歡的字體名稱 然后重新部署即可 根据程序切换中英文鼠须管 0.9.9 之后开始支持在指定的应用程序中设定输入法的初始状态。 如在 终端 Terminal、iTerm2 编辑器 sublime、atom 启动工具 QuickSilver、Alfred 中我们很少会用到中文，于是我们可能设置鼠须管在这种程序中默认英文输入 如果想要设置应用中输入法的初始状态，我们首先要查看应用的Info.plist文件得到该应用的Bundle Identifier，通常是形如com.apple.Xcode的字符串 例如，要在Xcode中默认英文输入，又要在Alfred中恢复中文输入，可如下设定： 12345# example squirrel.custom.yamlpatch: app_options/com.apple.Xcode: ascii_mode: true app_options/com.alfredapp.Alfred: &#123;&#125; emoji表情以及特殊符号有时候我们会有输入emoji表情的需求，但仅仅只是开启了emoji输入方案的话，我们每次都要切换输入方案才可以输入emoji表情，还是很不方便的。如果可以直接在一种输入方案中加入emoji表情输入就更好了 其实可以做到，你只需要这样 1234567891011121314151617181920# luna_pinyin.custom.yaml## 在【朙月拼音】裏使用Emoji表情## 保存到Rime用戶文件夾後，重新部署生效# ~/.config/ibus/rime (linux)# ~/Library/Rime (macos)# %APPDATA%\\Rime (windows)## 如果目標文件已經包含其他修改內容，只需按照縮進合併 patch: 以下的部分#patch: schema/dependencies: - emoji reverse_lookup: dictionary: emoji enable_completion: false prefix: \"`\" tips: 〔表情〕 以上我们就完成了emoji表情输入的设置，现在输入一个`加随意一些字母来看看效果吧 但是仅仅表情还不够，我们有时候需要输入形如ⅺ、⑴、☁之类的特殊符号，查看symbols.yaml我们可以发现及其丰富的特殊符号，但是如何才能使用它们呢？ 只需要在我们上面已经添加了emoji表情相关的配置文件末尾再加上如下配置即可 12345678punctuator: import_preset: symbolsrecognizer: import_preset: default patterns: reverse_lookup: \"`[a-z]*'?$\" punct: \"^/([a-z]+|[0-9]0?)$\" 大功告成，重新部署之后使用/lm看看吧，更多符号输入方式请查看symbols.yaml 同步做了这么多的个性化设置之后，其实输入法应该已经很符合自己的心意了。但是如果我们更换了一台设备或者需要在其它设备上保持同样的习惯的话怎么办呢？我们使用这么久已经养成了的个人词库可以在其它设备上使用么？ 当然可以！ RIME是支持同步的，但是它的同步方式和市面上主流的输入法不一样，需要我们自己使用同步网盘或者U盘来同步。 推荐国内用户使用坚果云作为同步盘使用，坚果云拥有多平台客户端且在墙内使用情况良好。若肉身在墙外则推荐DropBox 1. 设定同步位置默认情况下，个人词库和配置都将备份到RIME用户文件夹\\sync\\UUID这里。如果使用网盘或者U盘在不同机器、系统之间同步，则需要设定同步的目标文件夹，此时这些文件都会备份到设定好的目录。 直接編輯用戶文件夾下的installation.yaml，添加： 1sync_dir: 'D:\\Dropbox\\RimeSync' 又如 Mac 上添加： 1sync_dir: '/Users/fred/Dropbox/RimeSync' 又如使用 USB 存儲來同步：（真實案例） 1sync_dir: '/Volumes/USBDRIVE/RimeSync' 2. 同步标识默认情况下，RIME会为随机生成每一个UUID作为标识。这个UUID会被用来区分來自不同机器/系统的个人词库和设置。 如果你想要让其更加便于管理，那么你可以设置一个有意义的ID用于区分，直接编辑installation.yaml中如下所示的内容即可 1installation_id: 'loshine-macbook' 注意：此ID不能使用非法字符，建议只用小写字母、数字、横线和下划线 我的成品成品效果演示 your browser does not support the video tag 几个配置文件 squirrel.custom.yaml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# 適用於【鼠鬚管】0.9.13+# 位置：~/Library/Rime/squirrel.custom.yaml# 用法：想要哪項生效，就刪去該行行首的#字符，但注意保留用於縮進的空格patch:# us_keyboard_layout: true # 鍵盤選項：應用美式鍵盤佈局 show_notifications_when: appropriate # 狀態通知，默認裝有Growl時顯示，也可設爲全開（always）全關（never）# style/horizontal: true # 候選窗横向顯示# style/inline_preedit: false # 非內嵌編碼行# style/font_face: \"PingFang SC,HanaMinA\" # 我喜歡的字體名稱 style/font_point: 18 # 字號 style/corner_radius: 2 # 窗口圓角半徑 style/border_height: 7 # 窗口邊界高度，大於圓角半徑才有效果 style/border_width: 7 # 窗口邊界寬度，大於圓角半徑才有效果 style/color_scheme: luna # 選擇配色方案# 註：預設的配色方案及代碼（指定爲 style/color_scheme ）# 碧水 - aqua# 青天 - azure# 明月 - luna# 墨池 - ink# 孤寺 - lost_temple# 暗堂 - dark_temple# 星際我爭霸 - starcraft# 谷歌 - google preset_color_schemes/textflow: author: \"name &lt;name@gmail.com&gt;\" back_color: 0xFFFFFF #背景 border_color: 0xE0B693 #边框 candidate_text_color: 0x000000 #非第一候选项 hilited_back_color: 0xEBECED #拼音串高亮背景 hilited_candidate_back_color: 0xFFFFFF #第一候选项背景 hilited_candidate_text_color: 0xF57C75 #第一候选项 hilited_text_color: 0xFF6666 #拼音串高亮 name: Textflow text_color: 0x000000 #拼音串# Xcode app_options/com.apple.Xcode: ascii_mode: true# alfred app_options/com.alfredapp.Alfred: ascii_mode: true# Android Studio app_options/com.google.android.studio: ascii_mode: true# atom app_options/com.github.atom: ascii_mode: true default.custom.yaml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960patch: schema_list: - schema: luna_pinyin # 朙月拼音 - schema: luna_pinyin_fluency # 朙月拼音 语句流# - schema: luna_pinyin_simp # 朙月拼音 简化字模式# - schema: luna_pinyin_tw # 朙月拼音 臺灣正體模式 - schema: terra_pinyin # 地球拼音 dì qiú pīn yīn# - schema: bopomofo # 注音# - schema: bopomofo_tw # 注音 臺灣正體模式# - schema: jyutping # 粵拼# - schema: cangjie5 # 倉頡五代# - schema: cangjie5_express # 倉頡 快打模式# - schema: quick5 # 速成# - schema: wubi86 # 五笔86 - schema: wubi_pinyin # 五笔拼音混合輸入# - schema: double_pinyin # 自然碼雙拼# - schema: double_pinyin_mspy # 微軟雙拼# - schema: double_pinyin_abc # 智能ABC雙拼# - schema: double_pinyin_flypy # 小鶴雙拼# - schema: wugniu # 吳語上海話（新派）# - schema: wugniu_lopha # 吳語上海話（老派）# - schema: sampheng # 中古漢語三拼# - schema: zyenpheng # 中古漢語全拼# - schema: ipa_xsampa # X-SAMPA 國際音標 - schema: emoji # emoji表情&#123;% endhighlight %&#125;* terra_pinyin.custom.yaml&#123;% highlight yaml %&#125;# luna_pinyin.custom.yaml## 在【地球拼音】裏使用Emoji表情## 保存到Rime用戶文件夾後，重新部署生效# ~/.config/ibus/rime (linux)# ~/Library/Rime (macos)# %APPDATA%\\Rime (windows)## 如果目標文件已經包含其他修改內容，只需按照縮進合併 patch: 以下的部分#patch: schema/dependencies: - emoji# abc_segmentor/extra_tags:# - reverse_lookup reverse_lookup: dictionary: emoji enable_completion: false prefix: \"`\" tips: 〔表情〕 punctuator: import_preset: symbols recognizer: import_preset: default patterns: reverse_lookup: \"`[a-z]*'?$\" punct: \"^/([a-z]+|[0-9]0?)$\" installation.yaml 1234567distribution_code_name: Squirreldistribution_name: \"鼠鬚管\"distribution_version: 0.9.26.1install_time: \"Mon Aug 3 15:24:12 2015\"installation_id: \"loshine-macbook\"rime_version: 1.2.9sync_dir: '/Users/Loshine/我的坚果云/RimeSync'","categories":[{"name":"技术","slug":"技术","permalink":"https://loshine.me/categories/技术/"}],"tags":[{"name":"RIME","slug":"RIME","permalink":"https://loshine.me/tags/RIME/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://loshine.me/categories/技术/"}]},{"title":"Android网络通信框架Volley","slug":"volley","date":"2015-08-27T15:37:30.000Z","updated":"2016-11-16T17:09:19.000Z","comments":true,"path":"2015/08/27/volley/","link":"","permalink":"https://loshine.me/2015/08/27/volley/","excerpt":"","text":"之前我们在Android应用中的网络通信，一般都是使用AsyncTaskLoader，HttpURLConnection，AsyncTask，HTTPClient（Apache）等。但在 Google I/O 2013上，Google 发布了一个新的网络通信框架——Volley。Volley 适合数据量不大但通信十分频繁的场景，它使得Http通信操作相比以前更加简单、快捷、健壮。 Why之前从网络下载图片可能要这样： 在ListAdapter#getView()里开始图像的读取 通过 AsyncTask 等机制使用 HttpURLConnection 从服务器去的图片资源 在AsyncTask#onPostExecute()里设置相应 ImageView 的属性 再有，屏幕旋转的时候，有时候会导致再次从网络取得数据。为了防止不必要的网络访问，可能我们要自己实现 cache。 还有 ListView 滚动过快时，可能会导致有些网络请求返回数据时早已不需要显示了。 这些问题使用 Volley 都可以很简单地解决。 Volley 提供了如下的便捷功能： JSON，图像的异步下载 网络请求序列 网络请求优先级处理 缓存 多级别取消请求 和 Activity 生命周期的联动 人生苦短，快用 Volley！ How集成三种集成方法，其中后两种都是非官方渠道： 编译源码导入项目 从 Git 库 clone 最新版 1git clone https://android.googlesource.com/platform/frameworks/volley 编译为 jar 包 导入项目 Gradle构建（非官方渠道，推荐） 1compile 'com.mcxiaoke.volley:library:1.0.18' Maven构建（非官方渠道） 12345&lt;dependency&gt; &lt;groupId&gt;com.mcxiaoke.volley&lt;/groupId&gt; &lt;artifactId&gt;library&lt;/artifactId&gt; &lt;version&gt;&#123;latest-version&#125;&lt;/version&gt;&lt;/dependency&gt; 使用具体使用流程如下： 在 Activity 中构造一个（一个就够了）RequestQueue 请求序列对象 创建一个 Request 对象（子类实现） 添加到序列 开始序列 在这四步中，我们着重要关注的是第二步，Request 是一个抽象类，我们所以我们要用到它的子类实现，Volley中已经实现了以下几个子类： ClearCacheRequest ImageRequest JSONRequest StringRequest 下面我们就对这几个子类进行介绍以及给出示例 ClearCacheRequest虚构的请求，用于清空已有的缓存文件。 ClearCacheRequest的优先级很高，为Priority.IMMEDIATE，所以在被添加到 RequestQueue 后能很快执行。并且清空缓存的方法mCache.clear()写在了isCanceled()方法体中，能最早的得到执行。 ImageRequest待完成 JSONRequestJSONRequest 也是一个抽象类，所以我们在使用时要用到它的两个实现子类——JsonObjectRequest 和 JsonArrayRequest。 JsonObjectRequest 允许上传 JsonObject 数据，并根据请求返回数据。但 JsonArrayRequest 的实现过于简单，不能携带上传 json 数据，只能使用 GET 方式请求网络。 StringRequestStringRequest 是最为常用也是最灵活的 Request 实现。一个简单的 Get 请求获取百度首页的例子： 1234567891011121314151617181920212223242526272829303132333435363738public class StringRequestActivity extends AppCompatActivity &#123; /** * Volley 请求队列对象 */ private RequestQueue mRequestQueue; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_string_request); // 构造请求队列 mRequestQueue = Volley.newRequestQueue(context); StringRequest request = new StringRequest(\"http://www.baidu.com\", new Response.Listener&lt;String&gt;() &#123; @Override public void onResponse(String response) &#123; JSONObject jsonObject = JSON.parseObject(response, JSONObject.class); &#125; &#125;, new Response.ErrorListener() &#123; @Override public void onErrorResponse(VolleyError error) &#123; Log.i(\"net error\", error.getLocalizedMessage()); &#125; &#125;); mRequestQueue.add(request); &#125; @Override protected void onStop() &#123; super.onStop(); // 退出时取消所有网络请求 mRequestQueue.cancelAll(this); &#125;&#125; 自定义Request一个简单的使用 Pull 解析的 XMLRequest 123456789101112131415161718192021222324252627282930313233343536public class XMLRequest extends Request&lt;XmlPullParser&gt; &#123; private final Listener&lt;XmlPullParser&gt; mListener; public XMLRequest(int method, String url, Listener&lt;XmlPullParser&gt; listener, ErrorListener errorListener) &#123; super(method, url, errorListener); mListener = listener; &#125; public XMLRequest(String url, Listener&lt;XmlPullParser&gt; listener, ErrorListener errorListener) &#123; this(Method.GET, url, listener, errorListener); &#125; @Override protected Response&lt;XmlPullParser&gt; parseNetworkResponse(NetworkResponse response) &#123; try &#123; String xmlString = new String(response.data, HttpHeaderParser.parseCharset(response.headers)); XmlPullParserFactory factory = XmlPullParserFactory.newInstance(); XmlPullParser xmlPullParser = factory.newPullParser(); xmlPullParser.setInput(new StringReader(xmlString)); return Response.success(xmlPullParser, HttpHeaderParser.parseCacheHeaders(response)); &#125; catch (UnsupportedEncodingException e) &#123; return Response.error(new ParseError(e)); &#125; catch (XmlPullParserException e) &#123; return Response.error(new ParseError(e)); &#125; &#125; @Override protected void deliverResponse(XmlPullParser response) &#123; mListener.onResponse(response); &#125; &#125; 在parseNetworkResponse()方法中将服务器响应的数据解析成一个字符串，然后设置到XmlPullParser对象中。在deliverResponse()方法中则是将XmlPullParser对象进行回调。 与生命周期的联动当 Activity 里面启动了网络请求，如果这个网络请求还没返回结果的时候，Activity 就被结束了。此时如果继续使用其中的 Context 等会消耗没有必要的系统资源，而且还有可能会导致程序 crash。 所以在使用 Volley 时，我们应该在 Activity 停止的时候，同时取消所有或部分未完成的网络请求。Volley 里所有的请求结果会返回给主进程，如果在主进程里取消了某些请求，则这些请求将不会被返回给主线程。Volley 支持多种 Request 取消方式。 可以针对某些个 request 做取消操作 123456@Overridepublic void onStop() &#123; for (Request &lt;?&gt; req : mRequestQueue) &#123; req.cancel(); &#125;&#125; 取消这个队列里的所有请求 12345@Overrideprotected void onStop() &#123; super.onStop(); mRequestQueue.cancelAll(this);&#125; 可以根据 RequestFilter 或者 Tag 来终止某些请求 123456789@Override protected void onStop() &#123; super.onStop(); // 根据 RequestFilter mRequestQueue.cancelAll(new RequestFilter() &#123;&#125;); // 根据 Tag mRequestQueue.cancelAll(new Object());&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://loshine.me/categories/技术/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://loshine.me/tags/Android/"},{"name":"Volley","slug":"Volley","permalink":"https://loshine.me/tags/Volley/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://loshine.me/categories/技术/"}]},{"title":"Java中的模板方法模式","slug":"template-method-pattern-in-java","date":"2015-08-25T05:50:30.000Z","updated":"2016-11-16T17:09:19.000Z","comments":true,"path":"2015/08/25/template-method-pattern-in-java/","link":"","permalink":"https://loshine.me/2015/08/25/template-method-pattern-in-java/","excerpt":"","text":"准备一个抽象类，将部分逻辑以具体方法以及具体构造子的形式实现，然后声明一些抽象方法来迫使子类实现剩余逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。模版方法模式是基于继承的代码复用的基本技术。 结构模板方法模式需要开发抽象类和具体子类的设计师之间的协作。一个设计师负责给出一个算法的轮廓和骨架，另一些设计师则负责给出这个算法的各个逻辑步骤。代表这些具体逻辑步骤的方法称做基本方法(primitive method)；而将这些基本方法汇总起来的方法叫做模板方法(template method)，这个设计模式的名字就是从此而来。 模板方法所代表的行为称为顶级行为，其逻辑称为顶级逻辑。模板方法模式的静态结构图如下所示： 这里涉及到两个角色： 抽象模板(Abstract Template)角色： 定义了一个或多个抽象操作，以便让子类实现。这些抽象操作叫做基本操作，它们是一个顶级逻辑的组成步骤。 定义并实现了一个模板方法。这个模板方法一般是一个具体方法，它给出了一个顶级逻辑的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现。顶级逻辑也有可能调用一些具体方法。 具体模板(Concrete Template)角色： 实现父类所定义的一个或多个抽象方法，它们是一个顶级逻辑的组成步骤。 每一个抽象模板角色都可以有任意多个具体模板角色与之对应，而每一个具体模板角色都可以给出这些抽象方法（也就是顶级逻辑的组成步骤）的不同实现，从而使得顶级逻辑的实现各不相同。 示例代码抽象模板角色类，abstractMethod()、doHookMethod()等基本方法是顶级逻辑的组成步骤，这个顶级逻辑由templateMethod()方法代表。 1234567891011121314151617181920212223242526272829public abstract class AbstractTemplate &#123; /** * 模板方法 */ public void templateMethod()&#123; // 调用基本方法 abstractMethod(); doHookMethod(); concreteMethod(); &#125; /** * 抽象方法，子类必须实现的方法 */ protected abstract void abstractMethod(); /** * 钩子方法，子类可选择是否实现。注意钩子方法一般以 do 开头 */ protected void doHookMethod()&#123;&#125; /** * 具体方法，由父类实现，子类无法 override */ private final void concreteMethod()&#123; // 业务相关的代码 &#125;&#125; 具体模板角色类，实现了父类所声明的基本方法，abstractMethod()方法所代表的就是强制子类实现的剩余逻辑，而doHookMethod()方法是可选择实现的逻辑，不是必须实现的。 1234567891011121314public class ConcreteTemplate extends AbstractTemplate &#123; // 基本方法的实现 @Override public void abstractMethod() &#123; // 业务相关的代码 &#125; // 重写父类的方法 @Override public void hookMethod() &#123; // 业务相关的代码 &#125;&#125; 模板方法模式的关键：子类可以置换掉父类的可变部分，但是子类却不可以改变模板方法所代表的顶级逻辑。 每当定义一个新的子类时，不要按照控制流程的思路去想，而应当按照责任的思路去想。换言之，应当考虑哪些操作是必须置换掉的，哪些操作是可以置换掉的，以及哪些操作是不可以置换掉的。使用模板模式可以使这些责任变得清晰。 在Servlet中的应用使用过Servlet的人都清楚，除了要在web.xml做相应的配置外，还需继承一个叫HttpServlet的抽象类。HttpService类提供了一个service()方法，这个方法调用七个do方法中的一个或几个，完成对客户端调用的响应。这些do方法需要由HttpServlet的具体子类提供，因此这是典型的模板方法模式。下面是service()方法的源代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String method = req.getMethod(); if (method.equals(METHOD_GET)) &#123; long lastModified = getLastModified(req); if (lastModified == -1) &#123; // servlet doesn't support if-modified-since, no reason // to go through further expensive logic doGet(req, resp); &#125; else &#123; long ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE); if (ifModifiedSince &lt; (lastModified / 1000 * 1000)) &#123; // If the servlet mod time is later, call doGet() // Round down to the nearest second for a proper compare // A ifModifiedSince of -1 will always be less maybeSetLastModified(resp, lastModified); doGet(req, resp); &#125; else &#123; resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED); &#125; &#125; &#125; else if (method.equals(METHOD_HEAD)) &#123; long lastModified = getLastModified(req); maybeSetLastModified(resp, lastModified); doHead(req, resp); &#125; else if (method.equals(METHOD_POST)) &#123; doPost(req, resp); &#125; else if (method.equals(METHOD_PUT)) &#123; doPut(req, resp); &#125; else if (method.equals(METHOD_DELETE)) &#123; doDelete(req, resp); &#125; else if (method.equals(METHOD_OPTIONS)) &#123; doOptions(req,resp); &#125; else if (method.equals(METHOD_TRACE)) &#123; doTrace(req,resp); &#125; else &#123; // // Note that this means NO servlet supports whatever // method was requested, anywhere on this server. // String errMsg = lStrings.getString(\"http.method_not_implemented\"); Object[] errArgs = new Object[1]; errArgs[0] = method; errMsg = MessageFormat.format(errMsg, errArgs); resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg); &#125;&#125; 当然，这个service()方法也可以被子类置换掉。 下面给出一个简单的 Servlet 例子： TestServlet 类是 HttpServlet 类的子类，并且置换掉了父类的两个方法：doGet()和doPost()： 12345678910111213141516public class TestServlet extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(\"using the GET method\"); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(\"using the POST method\"); &#125; &#125; 从上面的例子可以看出这是一个典型的模板方法模式。 HttpServlet 担任抽象模板角色 模板方法：由service()方法担任。 基本方法：由doPost()、doGet()等方法担任。 TestServlet 担任具体模板角色 TestServlet 置换掉了父类 HttpServlet 中七个基本方法中的其中两个，分别是doGet()和doPost()。","categories":[{"name":"技术","slug":"技术","permalink":"https://loshine.me/categories/技术/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://loshine.me/tags/设计模式/"},{"name":"Java","slug":"Java","permalink":"https://loshine.me/tags/Java/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://loshine.me/categories/技术/"}]},{"title":"Android Design Support Library","slug":"android-design-support-library","date":"2015-08-22T03:24:30.000Z","updated":"2016-11-16T17:09:19.000Z","comments":true,"path":"2015/08/22/android-design-support-library/","link":"","permalink":"https://loshine.me/2015/08/22/android-design-support-library/","excerpt":"","text":"Google 在2015的 IO 大会上，给我们带来了更加详细的 Material Design 设计规范，同时，也给我们带来了全新的 Android Design Support Library，在这个 support 库里面，Google 给我们提供了更加规范的 Material design 设计风格的控件。本文将介绍MD设计风格的兼容库以及它们的用法，也是对自己的学习做一个记录。 使用要使用非常简单，在Gradle中添加如下语句即可 1compile 'com.android.support:design:23.0.0' 组件SnackbarSnackbar 提供了一个介于 Toast 和 AlertDialog 之间轻量级控件，它可以很方便的提供消息的提示和动作反馈。其使用方式与Toast基本相同。 12345678910Snackbar.make(view, \"Snackbar comes out\", Snackbar.LENGTH_LONG) .setAction(\"Action\", new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText( MainActivity.this, \"Toast comes out\", Toast.LENGTH_SHORT).show(); &#125; &#125;).show(); 此处注意传入的第一个 view 是 Snackbar 显示的基准元素，Snackbar 会显示在该 view 的底部位置。Action 可以传入多个，每一个都可以配置点击事件。 显示效果： 官网API：Snackbar API TextInputLayout通常，单独的 EditText 会在用户输入第一个字母之后隐藏hint提示信息，但是现在你可以使用 TextInputLayout 来将 EditText 包裹起来，提示信息会变成一个显示在 EditText 之上的 floating label，这样用户就始终知道他们现在输入的是什么。同时，如果给 EditText 增加监听，还可以给它增加更多的 floating label。 使用方法： 12345678910&lt;android.support.design.widget.TextInputLayout android:id=\"@+id/til_pwd\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\"&gt; &lt;EditText android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\"/&gt;&lt;/android.support.design.widget.TextInputLayout&gt; 在代码中监听： 1234567891011121314151617181920212223TextInputLayout textInputLayout = (TextInputLayout) findViewById(R.id.til_pwd);EditText editText = textInputLayout.getEditText();textInputLayout.setHint(\"Password\");editText.addTextChangedListener(new TextWatcher() &#123; @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) &#123; if (s.length() &gt; 4) &#123; textInputLayout.setError(\"Password error\"); textInputLayout.setErrorEnabled(true); &#125; else &#123; textInputLayout.setErrorEnabled(false); &#125; &#125; @Override public void onTextChanged(CharSequence s, int start, int before, int count) &#123; &#125; @Override public void afterTextChanged(Editable s) &#123; &#125;&#125;); 注意：TextInputLayout 的颜色来自 style 中的 colorAccent 的颜色： 1&lt;item name=\"colorAccent\"&gt;#1743b7&lt;/item&gt; 显示效果： 官网API：TextInputLayout API Floating Action ButtonFloatingActionButton 是一个浮动显示的圆形按钮，Design library 中的 FloatingActionButton 实现了一个默认颜色为主题中 colorAccent 的悬浮操作按钮，like this： FloatingActionButton 的使用非常简单，一般将其放入 CoordinatorLayout 中。 1234567&lt;android.support.design.widget.FloatingActionButton android:id=\"@+id/fab\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"end|bottom\" android:layout_margin=\"@dimen/fab_margin\" android:src=\"@drawable/ic_done\"/&gt; 通过指定layout_gravity就可以指定它的位置。 同样，你可以通过指定anchor，即显示位置的锚点： 12345678&lt;android.support.design.widget.FloatingActionButton android:layout_height=\"wrap_content\" android:layout_width=\"wrap_content\" app:layout_anchor=\"@id/app_bar\" app:layout_anchorGravity=\"bottom|right|end\" android:src=\"@android:drawable/ic_done\" android:layout_margin=\"15dp\" android:clickable=\"true\"/&gt; 除了一般大小的悬浮操作按钮，它还支持 mini size（fabSize=&quot;mini&quot;）。FloatingActionButton 继承自 ImageView，你可以使用android:src或者 ImageView 的任意方法，比如setImageDrawable()来设置 FloatingActionButton 里面的图标。 官网API：Floating Action Button TabLayoutTabLayout既实现了固定的选项卡 - view的宽度平均分配，也实现了可滚动的选项卡 - view宽度不固定同时可以横向滚动。选项卡可以在程序中动态添加： 1234TabLayout tabLayout = (TabLayout) findViewById(R.id.tabs);tabLayout.addTab(tabLayout.newTab().setText(\"tab1\"));tabLayout.addTab(tabLayout.newTab().setText(\"tab2\"));tabLayout.addTab(tabLayout.newTab().setText(\"tab3\")); 通常 TabLayout 都会和 ViewPager 配合起来使用： 12345mViewPager = (ViewPager) findViewById(R.id.viewpager);// 设置 ViewPager 的数据等setupViewPager();TabLayout tabLayout = (TabLayout) findViewById(R.id.tabs);tabLayout.setupWithViewPager(mViewPager); 显示效果： 官网API：TabLayout API NavigationViewNavigationView 主要用于实现滑动显示的导航抽屉，这在 Material Design 中是十分重要的。使用 NavigationView，我们可以这样写导航抽屉了： 1234567891011121314151617181920&lt;android.support.v4.widget.DrawerLayout android:id=\"@+id/dl_main_drawer\" xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:fitsSystemWindows=\"true\"&gt; &lt;!-- 你的内容布局--&gt; &lt;include layout=\"@layout/navigation_content\"/&gt; &lt;android.support.design.widget.NavigationView android:id=\"@+id/nv_main_navigation\" android:layout_width=\"wrap_content\" android:layout_height=\"match_parent\" android:layout_gravity=\"start\" app:headerLayout=\"@layout/navigation_header\" app:menu=\"@menu/drawer_view\"/&gt;&lt;/android.support.v4.widget.DrawerLayout&gt; 其中最重要的就是这两个属性：app:headerLayout和app:menu 通过这两个属性，我们可以非常方便的指定导航界面的头布局和菜单布局： 其中最上面的布局就是app:headerLayout所指定的头布局： 1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"200dp\" android:background=\"?attr/colorPrimaryDark\" android:gravity=\"center\" android:orientation=\"vertical\" android:padding=\"16dp\" android:theme=\"@style/ThemeOverlay.AppCompat.Dark\"&gt; &lt;ImageView android:layout_width=\"100dp\" android:layout_height=\"100dp\" android:layout_marginTop=\"16dp\" android:background=\"@drawable/ic_user\"/&gt; &lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"16dp\" android:gravity=\"center\" android:text=\"XuYisheng\" android:textAppearance=\"@style/TextAppearance.AppCompat.Body1\" android:textSize=\"20sp\"/&gt;&lt;/LinearLayout&gt; 而下面的菜单布局，我们可以直接通过 menu 内容自动生成，而不需要我们来指定布局： 12345678910111213141516171819202122232425262728293031323334&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;menu xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;group android:checkableBehavior=\"single\"&gt; &lt;item android:id=\"@+id/nav_home\" android:icon=\"@drawable/ic_dashboard\" android:title=\"CC Talk\"/&gt; &lt;item android:id=\"@+id/nav_messages\" android:icon=\"@drawable/ic_event\" android:title=\"HJ Class\"/&gt; &lt;item android:id=\"@+id/nav_friends\" android:icon=\"@drawable/ic_headset\" android:title=\"Words\"/&gt; &lt;item android:id=\"@+id/nav_discussion\" android:icon=\"@drawable/ic_forum\" android:title=\"Big HJ\"/&gt; &lt;/group&gt; &lt;item android:title=\"Version\"&gt; &lt;menu&gt; &lt;item android:icon=\"@drawable/ic_dashboard\" android:title=\"Android\"/&gt; &lt;item android:icon=\"@drawable/ic_dashboard\" android:title=\"iOS\"/&gt; &lt;/menu&gt; &lt;/item&gt;&lt;/menu&gt; 你可以通过设置一个OnNavigationItemSelectedListener，使用其setNavigationItemSelectedListener()来获得元素被选中的回调事件。它可以让你处理选择事件，改变复选框状态，加载新内容，关闭导航菜单，以及其他任何你想做的操作。例如这样： 123456789101112private void setupDrawerContent(NavigationView navigationView) &#123; navigationView.setNavigationItemSelectedListener( new NavigationView.OnNavigationItemSelectedListener() &#123; @Override public boolean onNavigationItemSelected(MenuItem menuItem) &#123; menuItem.setChecked(true); mDrawerLayout.closeDrawers(); return true; &#125; &#125; &#125;);&#125; 官网API：NavigationView API AppBarLayoutAppBarLayout 是一个容器，会把所有放在里面的组件一起作为一个 AppBar。 这里就是把 Toolbar 和 TabLayout 放到了 AppBarLayout 中，让他们当做一个整体作为 AppBar。 12345678910111213141516171819&lt;android.support.design.widget.AppBarLayout android:id=\"@+id/appbar\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:theme=\"@style/ThemeOverlay.AppCompat.Dark.ActionBar\"&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" android:background=\"?attr/colorPrimary\" app:popupTheme=\"@style/ThemeOverlay.AppCompat.Light\"/&gt; &lt;android.support.design.widget.TabLayout android:id=\"@+id/tabs\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\"/&gt;&lt;/android.support.design.widget.AppBarLayout&gt; 官网API：AppBarLayout API CoordinatorLayoutCoordinatorLayout 是这次新添加的一个增强型的 FrameLayout。在 CoordinatorLayout 中，我们可以在 FrameLayout 的基础上完成很多新的操作。 Floating ViewMaterial Design 的一个新的特性就是增加了很多可悬浮的 View，像我们前面说的 Floating Action Button。我们可以把 FAB 放在任何地方，只需要通过： 1android:layout_gravity=\"end|bottom\" 来指定显示的位置。同时，它还提供了layout_anchor来供你设置显示坐标的锚点： 1app:layout_anchor=\"@id/appbar\" 创建滚动CoordinatorLayout 可以说是这次 support library 更新的重中之重。它从另一层面去控制子 view 之间触摸事件的布局，Design Library 中的很多控件都利用了它。 一个很好的例子就是当你将 FloatingActionButton 作为一个子 View 添加进 CoordinatorLayout 并且将 CoordinatorLayout 传递给Snackbar.make()，在3.0及其以上的设备上，Snackbar 不会显示在悬浮按钮的上面，而是 FloatingActionButton 利用 CoordinatorLayout 提供的回调方法，在 Snackbar 以动画效果进入的时候自动向上移动让出位置，并且在 Snackbar 动画地消失的时候回到原来的位置，不需要额外的代码。 官方的例子很好的说明了这一点： 123456789101112131415161718192021222324&lt;android.support.design.widget.CoordinatorLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;! -- Your Scrollable View --&gt; &lt;android.support.v7.widget.RecyclerView android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" app:layout_behavior=\"@string/appbar_scrolling_view_behavior\" /&gt; &lt;android.support.design.widget.AppBarLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\"&gt; &lt;android.support.v7.widget.Toolbar ... app:layout_scrollFlags=\"scroll|enterAlways\"&gt; &lt;android.support.design.widget.TabLayout ... app:layout_scrollFlags=\"scroll|enterAlways\"&gt; &lt;/android.support.design.widget.AppBarLayout&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 其中，一个可以滚动的组件，例如 RecyclerView、ListView（注意：目前貌似只支持RecyclerView、ListView，如果你用一个ScrollView，是没有效果的）。如果： 给这个可滚动组件设置了layout_behavior 给另一个控件设置了layout_scrollFlags 那么，当设置了layout_behavior的控件滑动时，就会触发设置了layout_scrollFlags的控件发生状态的改变。 设置的layout_scrollFlags有如下几种选项： scroll: 所有想滚动出屏幕的 view 都需要设置这个 flag，没有设置这个flag的view将被固定在屏幕顶部。 enterAlways: 这个 flag 让任意向下的滚动都会导致该view变为可见。 enterAlwaysCollapsed: 当你的视图已经设置 minHeight 属性又使用此标志时，你的视图只能以最小高度进入，只有当滚动视图到达顶部时才扩大到完整高度。 exitUntilCollapsed: 向上滚动时收缩 View。 需要注意的是，后面两种模式基本只有在 CollapsingToolbarLayout 才有用，而前面两种模式基本是需要一起使用的，也就是说，这些 flag 的使用场景，基本已经固定了。 例如我们前面例子中的，也就是这种模式： 1app:layout_scrollFlags=\"scroll|enterAlways\" PS：所有使用 scroll flag 的 view 都必须定义在没有使用 scroll flag 的 view 的前面，这样才能确保所有的 view 从顶部退出，留下固定的元素。 官网API：CoordinatorLayout CollapsingToolbarLayoutCollapsingToolbarLayout 提供了一个可以折叠的 Toolbar，这也是 Google+、photos 中的效果。Google 把它做成了一个标准控件，更加方便使用。 这里先看一个例子： 123456789101112131415161718192021222324252627282930313233343536&lt;android.support.design.widget.AppBarLayout android:id=\"@+id/appbar\" android:layout_width=\"match_parent\" android:layout_height=\"@dimen/detail_backdrop_height\" android:fitsSystemWindows=\"true\" android:theme=\"@style/ThemeOverlay.AppCompat.Dark.ActionBar\"&gt; &lt;android.support.design.widget.CollapsingToolbarLayout android:id=\"@+id/collapsing_toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:fitsSystemWindows=\"true\" app:contentScrim=\"?attr/colorPrimary\" app:expandedTitleMarginEnd=\"64dp\" app:expandedTitleMarginStart=\"48dp\" app:layout_scrollFlags=\"scroll|exitUntilCollapsed\"&gt; &lt;ImageView android:id=\"@+id/backdrop\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:fitsSystemWindows=\"true\" android:scaleType=\"centerCrop\" android:src=\"@drawable/ic_banner\" app:layout_collapseMode=\"parallax\"/&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" app:layout_collapseMode=\"pin\" app:popupTheme=\"@style/ThemeOverlay.AppCompat.Light\"/&gt; &lt;/android.support.design.widget.CollapsingToolbarLayout&gt;&lt;/android.support.design.widget.AppBarLayout&gt; 我们在 CollapsingToolbarLayout 中放置了一个 ImageView 和一个 Toolbar。并把这个 CollapsingToolbarLayout 放到 AppBarLayout 中作为一个整体。在 CollapsingToolbarLayout 中，我们分别设置了 ImageView 和一个 Toolbar 的layout_collapseMode。 这里使用了 CollapsingToolbarLayout 的app:layout_collapseMode=&quot;pin&quot;来确保 Toolbar 在 view 折叠的时候仍然被固定在屏幕的顶部。当你让 CollapsingToolbarLayout 和 Toolbar 在一起使用的时候，title 会在展开的时候自动变得大些，而在折叠的时候让字体过渡到默认值。必须注意，在这种情况下你必须在 CollapsingToolbarLayout 上调用setTitle()，而不是在 Toolbar 上。 除了固定住 view，你还可以使用app:layout_collapseMode=&quot;parallax&quot;（以及使用app:layout_collapseParallaxMultiplier=&quot;0.7&quot;来设置视差因子）来实现视差滚动效果（比如 CollapsingToolbarLayout 里面的一个 ImageView），这中情况和 CollapsingToolbarLayout 的app:contentScrim=&quot;?attr/colorPrimary&quot;属性一起配合更完美。 在这个例子中，我们同样设置了： 1app:layout_scrollFlags=\"scroll|exitUntilCollapsed\"&gt; 来接收一个： 1app:layout_behavior=\"@string/appbar_scrolling_view_behavior\"&gt; 这样才能产生滚动效果，而通过layout_collapseMode，我们就设置了滚动时内容的变化效果。 CoordinatorLayout与自定义view有一件事情必须注意，那就是 CoordinatorLayout 并不知道 FloatingActionButton 或者 AppBarLayout 的内部工作原理，它只是以Coordinator.Behavior的形式提供了额外的 API，该 API 可以使子 View 更好的控制触摸事件与手势以及声明它们之间的依赖，并通过onDependentViewChanged()接收回调。 可以使用CoordinatorLayout.DefaultBehavior(你的View.Behavior.class)注解或者在布局中使用app:layout_behavior=&quot;com.example.app.你的View$Behavior&quot;属性来定义view的默认行为。framework让任意view和CoordinatorLayout结合在一起成为了可能。 官方API：CollapsingToolbarLayout 总结研究了一整天的 Android Design Support Library，感觉还是非常强大的。虽然自定义性不是很强，但已经给开发者提供了很简单方便的 Material Design 的官方实现，也不用集成很多的第三方库了，还是很不错的，推荐大家在自己的项目中使用。 参考Thanks to 《Android Design Support Library使用详解》","categories":[{"name":"技术","slug":"技术","permalink":"https://loshine.me/categories/技术/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://loshine.me/tags/Android/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://loshine.me/categories/技术/"}]},{"title":"Android Studio常用快捷键","slug":"android-studio-keymap","date":"2015-08-20T14:31:30.000Z","updated":"2016-11-16T17:09:19.000Z","comments":true,"path":"2015/08/20/android-studio-keymap/","link":"","permalink":"https://loshine.me/2015/08/20/android-studio-keymap/","excerpt":"","text":"之前直接把 Android Studio 的 keymap 改为了 Eclipse 模式，但毕竟这样不利于 Android Studio 的学习，所以这里也记录一下 Android Studio 的快捷键，便于以后查看。 快捷键 Action Mac OSX Win/Linux 注释代码(//) Cmd + / Ctrl + / 注释代码(/**/) Cmd + Option + / Ctrl + Shift + / 格式化代码 Cmd + Option + L Ctrl + Alt + L 清除无效包引用 Option + Control + O Alt + Ctrl + O 查找 Cmd + F Ctrl + F 查找+替换 Cmd + R Ctrl + R 上下移动代码 Option + Shift + Up/Down Alt + Shift + Up/Down 删除行 Cmd + Delete Ctrl + Y 扩大缩小选中范围 Option + Up/Down Ctrl + W/Ctrl + Shift + W 快捷生成结构体 Cmd + Option + T Ctrl + Alt + T 快捷覆写方法 Cmd + O Ctrl + O 快捷定位到行首/尾 Cmd + Left/Right Ctrl + Left/Right 折叠展开代码块 Cmd + Plus,Minus Ctrl + Plus/Minus 折叠展开全部代码块 Cmd + Shift + Plus,Minus Ctrl + Shift + Plus,Minus 文件方法结构 Cmd + F12 Ctrl + F12 查找调用的位置 Ctrl + Option + H Ctrl + Alt + H 大小写转换 Cmd + Shift + U Ctrl + Shift + U 编译项目 Cmd + F9 Ctrl + F9 运行项目 Ctrl + R Ctrl + R 代码提示 Option + Space Alt + Space (PS: 以上快捷键没有在 win 平台尝试确认，如有错误可以在评论中反馈)","categories":[{"name":"技术","slug":"技术","permalink":"https://loshine.me/categories/技术/"}],"tags":[{"name":"Android Studio","slug":"Android-Studio","permalink":"https://loshine.me/tags/Android-Studio/"},{"name":"Android","slug":"Android","permalink":"https://loshine.me/tags/Android/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://loshine.me/categories/技术/"}]},{"title":"Java中的单例设计模式","slug":"singleton-in-java","date":"2015-08-18T03:19:30.000Z","updated":"2016-11-16T17:09:19.000Z","comments":true,"path":"2015/08/18/singleton-in-java/","link":"","permalink":"https://loshine.me/2015/08/18/singleton-in-java/","excerpt":"","text":"单例模式确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。 特点单例模式有以下特点： 单例类只能有一个实例 单例类必须自己创建自己的唯一实例 单例类必须给所有其他对象提供这一实例 实现饿汉式饿汉式在类创建的同时就已经创建好一个静态的对象供系统使用，以后不再改变，所以天生是线程安全的。 123456789101112public class Singleton &#123; // 饿汉式，开始就建立一个对象 private static final Singleton single = new Singleton(); // 将构造函数私有，禁止在其它类中创建对象 private Singleton() &#123;&#125; public static Singleton getInstance() &#123; return single; &#125;&#125; 懒汉式懒汉式则是在调用获取实例对象的方法时检查，若没有对象则创建对象，如果单例对象已经存在则不创建对象直接返回已存在的对象。 123456789101112131415public class Singleton &#123; // 懒汉式，刚开始不创建对象 private static Singleton single=null; // 将构造函数私有，禁止在其它类中创建对象 private Singleton() &#123;&#125; // 静态工厂方法 public static Singleton getInstance() &#123; if (single == null) &#123; single = new Singleton(); &#125; return single; &#125;&#125; 这种懒汉式实现是非线程安全的，并发环境下很可能出现多个Singleton实例。若要保证线程安全，我们可以使用如下几种方式 同步getInstance()方法 123456public static synchronized Singleton getInstance() &#123; if (single == null) &#123; single = new Singleton(); &#125; return single;&#125; 代码块加锁和双重检查 12345678910public static Singleton getInstance() &#123; if (singleton == null) &#123; synchronized (Singleton.class) &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton;&#125; 静态内部类 123456789101112131415public class Singleton &#123; // 用于封装单例实例的内部类 private static class LazyHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; // 私有构造 private Singleton() &#123;&#125; // 获取单例实例的方法 public static final Singleton getInstance() &#123; return LazyHolder.INSTANCE; &#125; &#125; 其中第三种实现方式最好，避免了加锁的效率问题。但实际开发中饿汉式使用较多。","categories":[{"name":"技术","slug":"技术","permalink":"https://loshine.me/categories/技术/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://loshine.me/tags/设计模式/"},{"name":"Java","slug":"Java","permalink":"https://loshine.me/tags/Java/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://loshine.me/categories/技术/"}]},{"title":"使用Jekyll在Github-Pages上搭建个人博客","slug":"build-personal-blog-in-github-pages-with-jekyll","date":"2015-08-17T02:12:30.000Z","updated":"2016-11-16T17:09:19.000Z","comments":true,"path":"2015/08/17/build-personal-blog-in-github-pages-with-jekyll/","link":"","permalink":"https://loshine.me/2015/08/17/build-personal-blog-in-github-pages-with-jekyll/","excerpt":"","text":"我的个人博客也在Github-Pages上搭建起来了，其中各个步骤参照了《“授人以渔”的教你搭建个人独立博客》——Azure Yu、《Using Jekyll with Pages》。鄙人于此也作一下使用Jekyll在Github-Pages上搭建个人博客的总结，也可以给其他后来者做一些参考。 本文默认读者已经拥有了Github的帐号，并且对Git的使用较为熟练。如果对Git以及Github不是很了解，可以参考《版本控制入门 – 搬进 Github》。 在这个过程中可能需要使用到少许的Ruby知识，如果您需要学习，可以看这里 开始新建一个仓库 如果没有Github帐号，首先注册一个。 接下来新建一个仓库 注：Repository name(仓库名)必须是 yourusername.github.io 比如我的用户名是loshine，那么我的这个仓库名就是loshine.github.io clone到本地使用Github客户端或者Git命令行工具将这个项目clone到本地。 上传页面之后，新建一个index.html文件，push到对应的master分支（推荐官网教程）。等一段时间之后（可以听首歌），网站生效，访问yourusername.github.io，就能看见完整的网页了。 建造 搭建本地环境由于我们使用Jekell来将markdown文件生成博客文章，所以我们需要搭建本地的Jekyll环境。 Ruby - Mac已经自带了Ruby，所以无需再次安装。如果是其它系统且没有安装Ruby，请安装Ruby环境。 Bundler - 打开终端输入gem install bundler以安装。 github-pages - 打开终端输入gem install github-pages以安装。 Jekyll - 打开终端输入gem install jekyll以安装。 注: 如果你在墙内则可能会出现无法安装的问题，可以通过将Gem源更换为淘宝镜像源解决。 Jekyll的使用 在我们之前创建的仓库下新建一个文件，命名为Gemfile，并写入gem &#39;github-pages&#39;。 在仓库目录下打开命令行工具，输入bundle install。 在命令行工具中输入bundle exec jekyll serve，按提示打开地址，就可以在本地进行查看和调试网站了。 Jekyll目录解析123456789101112131415161718|—— _config.yml|—— _includes |—— footer.html |—— header.html|—— _layouts |—— default.html |—— post.html|—— _posts |—— 2015-04-09-welcome-to-jekyll.md |—— 2015-08-17-使用Jekyll在Github-Pages上搭建个人博客.md|—— _site|—— css |—— *.css|—— script |—— *.js|—— Gemfile|—— Gemfile.lock|—— index.html 接下来按顺序介绍一下以上文件目录树的每一个文件夹以及文件的作用。 _config.yml 配置文件，你可以在里面配置你博客会用到的常量，比如博客名，邮件 _includes 文章各个部分的html文件，可以在布局中包含这些文件 _layouts 存放模板。就是你网页的布局，主页布局，文章布局。当然不是指CSS那样的布局，是指，你包含哪些基本的内容到页面上。包含的内容就是includes里面的文件。 _posts 存放博客文章 CNAME 域名地址 css 存放博客所用css script 存放博客所用JavaScript index.html 博客主页写博客 博客文章都是用markdown格式书写，命名格式为时间加标题，形如：2015-08-17-使用Jekyll在Github-Pages上搭建个人博客.md 文章需要在开头位置加入一段特殊的文字，其中定义了使用到的样式、文章标题、时间、分类。 123456---layout: posttitle: \"Welcome to Jekyll!\"date: 2014-01-27 21:57:11categories: Blog--- 完成了以上的步骤，就可以开始撰写博客了。写完之后记得把它放入_post文件夹中，并同步到Github上哦。 装修使用模板之前在Jekyll目录解析中我们大致了解了各个目录的结构。如果您是一名资深的前端工程师，那么就可以直接开始编写自己喜欢的样式的博客了。如果您对于前端并不是那么擅长，那么您可以直接在Jekyll 主题中选择自己喜欢的主题并放入到自己的项目中去。 以我的博客为例，我选择了Pithy主题，将其下载了下来，然后放入了自己的项目中，覆盖已有的文件，然后在终端中输入bundle exec jekyll serve运行jekyll服务器，打开http://localhost:4000就可以查看到效果了。 自定义样式如果您不是一名资深的前端工程师但是还是想要自己定义自己博客的样式。那么我推荐您Run Noob、w3cschool这两个地方学习前端知识。之后您就可以根据自己的需求装点自己的博客了。 定制使用独立域名 新建一个文件，命名为CNAME，然后在里面写入你需要绑定的独立域名就可以了。 在你的域名服务商处添加解析地址。 完成以上步骤你就可以使用自己的独立域名了。 添加评论功能多说多说评论对国内的社交帐号支持不错，自定义性也很强，是一个不错的选择。 登录多说，创建一个项目，拷贝你的通用代码。 在_include文件夹里新建一个comment.html文件，将通用代码粘贴进去。 修改通用代码中需要配置的地方 12&lt;div class=\"ds-thread\" data-thread-key=\"请将此处替换成文章在你的站点中的ID\" data-title=\"请替换成文章的标题\" data-url=\"请替换成文章的网址\"&gt;&lt;/div&gt; 修改为 12&lt;div class=\"ds-thread\" data-thread-key=\"【 page.id 】\" data-title=\"【 page.title 】\" data-url=\"your web site【 page.url 】\"&gt;&lt;/div&gt; 注意【】需要替换为两个大括号，your web site需替换为您的域名地址。 在_layout中的post.html中的底部加入【% include comment.html %】（【】须替换为{}） 在多说的控制台里你可以设置很多自定义项，如：评论审核、评论显示方式、关键词过滤、主题、自定义CSS等 DisqusDisqus支持使用Disqus、Facebook、Twitter以及Google帐号登录，如果你的博客不是主要面向国内普通用户的话，可以考虑使用Disqus。 注册Disqus 右上角设置项中选择Add Disqus To Site，按步骤走，最后复制生成的Universal Code 其它部分类似如上的集成多说操作，但不需要自己修改代码了 Disqus也有控制台可以对评论进行操作 注意：Disqus在国内的访问速度可能比较慢，可能需要慎重考虑使用。 参考 《“授人以渔”的教你搭建个人独立博客》——Azure Yu 官方文档","categories":[{"name":"技术","slug":"技术","permalink":"https://loshine.me/categories/技术/"}],"tags":[{"name":"jekyll","slug":"jekyll","permalink":"https://loshine.me/tags/jekyll/"},{"name":"github","slug":"github","permalink":"https://loshine.me/tags/github/"},{"name":"github-pages","slug":"github-pages","permalink":"https://loshine.me/tags/github-pages/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://loshine.me/categories/技术/"}]}]}